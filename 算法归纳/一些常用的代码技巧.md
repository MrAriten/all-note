# 一些常用的代码技巧

## ① vector的数组弹出

```C++
vector.pop_out()
```

这个技巧在回溯里十分有用，相较于copy一个之前的数组，这个能节省很多时间和空间

## ② 数组的唯一化必须要先经过排列！

```C++
sort(total_answer.begin(),total_answer.end());
auto end_unique = unique(total_answer.begin(),total_answer.end());
total_answer.erase(end_unique,total_answer.end());
```

unique函数是将==相邻==的重复元素删除，而不是直接删除重复元素！所以必须排列！

## ③ 无序容器map和unordermap的迭代器是没有 + 1的！

无序容器的迭代器不能和常数操作！但是可以++，就很奇怪！

## ④ 对于需要构造的容器，emplace_back比push_back更好！

push_back是先构造后复制，而emplace_back是直接构造！

## ⑤ 二维数组vector的初始化

```C++
vector<vector<int>> a (m,vector<int>(n));
vector<vector<int>> a (m,vector<int>(n,0));
```

后面一个参数是vector<int>而不是数字！第二行的0代表初始化为0！

## ⑥空字符串的rbegin == rend且begin == end!!!

所以不能解引用空字符串的begin迭代器！

## ⑦ 当你将一个负数反转时，注意INT_MIN不能反转！！

INT_MAX = -INT_MIN - 1！！如果直接反转会越界！！

## ⑧ vector.size() - 1 才是数组的末尾下标！！

## ⑨ lambda函数排序，小于号<是按数字顺序拍，大于号>是按逆序！！

## ⑩返回数组的最后一个元素，直接用vector.back()就行了！

## 十一、和二进制相关的，可以先考虑用bitset！但是bitset要先设置位数，比较麻烦

## 十二、string创建空白不能用(" ",count)

如果这样的话，只有第一个字符是“ ”，后面的字符全是/0！！我也不知道为啥。

## 十三、善用数学函数

在cmath头文件中有很多数学相关的函数

例如exp()和log()，前者是e的次方，后者是loge。

## 十四、学会用辅助栈或者辅助队列！！！

## 十五、单调栈

https://baike.baidu.com/item/%E5%8D%95%E8%B0%83%E6%A0%88/2485465?fr=aladdin

## 十六、链表中不要误把nullptr记录了！是保留不了指针的！

比如创建了一个head，它的next是nullptr，这时候你创建一个新的指针headnext = head->next，然后后面的代码修改了head->next，那么headnext是不会改变的！！

因为一开始的headnext是nullptr！！是不具备保留指针地址的功能的！！

## 十七、在public中创建空数组不能用括号！！编译器无法判断是函数还是数组！！

```C++
public:
    vector<int> point_pos = vector<int>(3);
	vector<int> point_pos(3);
//这两个就是区别，在类中第一个是可以的，第二个是不行的！因为会产生歧义！
```

## 十八、在用树和链表的时候！！root不是它的值！！

有时候你经常把root当做int了！！root是指针！！root->val才是值！！

## 十九、队列可以push_front也可以push_back!!!

也就是既可以当栈用也可以当队列用！！

## 二十、遍历for不用int i也能顺序输入的方法

```C++
        for (auto& val : inorder) {
            idx_map[val] = idx++;
        }
```

## 二十一、root在使用left和right的时候，要先判断if(!root)！！

## 二十二、链表找中位数，快慢指针法！

用一个fast指针和slow指针，fast每次移动两位，slow移动一位，最后当fast到最后一位时，slow就是中位数

```C++
ListNode* slow = head, *fast = head;//快慢节点找中点
        while (fast != tail) {
            slow = slow->next;
            fast = fast->next;
            if (fast != tail) {
                fast = fast->next;
            }
        }
        ListNode* mid = slow;//fast到tail的时候slow就是中点
```



## 二十三、自我递归可以用变量存储值

力扣110题就是这种例子

回归深度时，可以用两个数来存储深度，这样就不会说你想对回归的数操作不了

```C++
class Solution {
public:
    int getHeight(TreeNode * root)
    {
        if(!root) return 0;
        int left_height = getHeight(root->left);//记录数值，而不是直接放在return里
        int right_height = getHeight(root->right);
        if(abs(left_height - right_height) > 1 || left_height == -1 || right_height == -1) return -1;
        return max(left_height,right_height) + 1;
    }
    bool isBalanced(TreeNode* root) 
    {
        if(getHeight(root) == -1) return false;
        return true;
    }
};
```

## 二十四、原地算法并不是O(1)，而是在原地修改结构！！

## 二十五、更多的数据类型

```C++
/* There is some amount of overlap with <sys/types.h> as known by inet code */
#ifndef __int8_t_defined
# define __int8_t_defined
typedef signed char             int8_t;
typedef short int               int16_t;
typedef int                     int32_t;
# if __WORDSIZE == 64
typedef long int                int64_t;
# else
__extension__
typedef long long int           int64_t;
# endif
# endif

/* Unsigned.  */
typedef unsigned char           uint8_t;
typedef unsigned short int      uint16_t;
#ifndef __uint32_t_defined
typedef unsigned int            uint32_t;
# define __uint32_t_defined
#endif
#if __WORDSIZE == 64
typedef unsigned long int       uint64_t;
#else
__extension__
typedef unsigned long long int  uint64_t;
#endif
```

## 二十六、“环形”数组

对于某些题，是把数组当做一个可以循环的圈的，但是从数据结构上说数组不是圈，那么如何实现类似圈的效果？

力扣的134题就是类似的题目

```C++
int n = vector.size();
        int i = 0;
        while (i < n) { //将i当做起点
            int cnt = 0;//cnt作为“环”的起点
            while (cnt < n) {
                int j = (i + cnt) % n; //将cnt映射到数组中的位置
                ……
```

## 二十七、位逻辑运算符

第136和137都是很好的位逻辑题

```C++
&，=&//按位与
|，=|//按位或
^,=^//按位异或
<< //左移
>> //右移
```

## 二十八、数组vector可以用find！！
