# 动态规划

如何发现题可以用动态规划？

对于“无后效性”的题目，基本都能用动态规划，比如说f(i,j) = f(i-1,j) + f(j-1,i)这种，当前状态只和先前的状态有关的题目。

动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类，比如这里的统计方案数的问题，它们都存在一定的递推性质。前者的递推性质还有一个名字，叫做 「最优子结构」 ——即当前问题的最优解取决于子问题的最优解，后者类似，当前问题的方案数取决于子问题的方案数。所以在遇到求方案数的问题时，我们可以往动态规划的方向考虑。
通常如果我们察觉到了这两点要素，这个问题八成可以用动态规划来解决。读者可以多多练习，熟能生巧。

## ① 定义

动态规划算法：多阶段决策过程，每步求解的问题是后面阶段求解问题的子问题，每步决策将依赖于以前步骤的决策结果；

也就是说，每一个问题，都由其子问题来决定，子问题会影响其下一个问题的答案。

一般那些最优问题都可以用动态规划求解。

## ② 动态规划的解题步骤

a、确定状态 -> 研究最后问题的最后一步 -> 将最后一步转换为子问题

b、转移方程 -> 根据子问题的定义得到

c、 求取初始状态和边界条件

d、 从头到尾顺序计算问题答案

比较经典的例子：力扣第32题——最长有效括号

https://leetcode.cn/problems/longest-valid-parentheses/solution/dong-tai-gui-hua-si-lu-xiang-jie-c-by-zhanganan042/

这个题解很好的讲解了如何运用动态规划！！

## ③ 起始条件

对于一维动态规划，起始条件一般是dp[0]和dp[1]！——力扣32题

而对于二维动态规划，起始条件一般是dp[i] [0]和dp[0] [i]，第一行和第一列！ ——力扣第44题

## ④滚动数组

第63和第62也是动态规划的经典题目，对于大部分的二维动态规划问题，都可以用滚动数组来节省空间复杂度

 最典型的就是斐波那契数列，普通的求解方法不外乎就是用递推式f[i]=f[i-1]+f[i-2]，但是这个如果数据量大的话会爆内存，而用滚动数组的方法可以用3个单位大小的空间求得解，这样就节省了很多的空间。

对于第63题，虽然动态规划方程是f(i,j) = f(i-1,j) + f(i , j-1) ，但是可以通过降维，将f变成一个一维数组，从上往下一行一行地加，这样空间复杂度就降了一维！

而对于第115题，dp[i][j] = dp[i-1] [j-1] + dp[i-1] [j];这种就不能用滚动数组！！因为每次更新都会用到 dp[i-1] [j-1] ，如果只用一行是会被覆盖掉的！