# 第169题 多数元素

下面这些方法数据结构课本中都有提到过，可以查阅课本

## ① 哈希表法：

```C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int, int> counts;
        int majority = 0, cnt = 0;
        for (int num: nums) {
            ++counts[num];
            if (counts[num] > cnt) {
                majority = num;
                cnt = counts[num];
            }
        }
        return majority;
    }
};
```

最简单的思路就是用哈希表存储每个元素的值，最后再从哈希表中找到最大的那个数就行了。

## ②分治法

```C++
class Solution {
    int count_in_range(vector<int>& nums, int target, int lo, int hi) {
        int count = 0;
        for (int i = lo; i <= hi; ++i)
            if (nums[i] == target)
                ++count;
        return count;
    }
    int majority_element_rec(vector<int>& nums, int lo, int hi) {
        if (lo == hi)
            return nums[lo];
        int mid = (lo + hi) / 2;
        int left_majority = majority_element_rec(nums, lo, mid);
        int right_majority = majority_element_rec(nums, mid + 1, hi);
        if (count_in_range(nums, left_majority, lo, hi) > (hi - lo + 1) / 2)
            return left_majority;
        if (count_in_range(nums, right_majority, lo, hi) > (hi - lo + 1) / 2)
            return right_majority;
        return -1;
    }
public:
    int majorityElement(vector<int>& nums) {
        return majority_element_rec(nums, 0, nums.size() - 1);
    }
};
```

分治法的核心是将数组分为两半，分别去找各半边数组的众数，不断向下衍生直到最后一个数，两半数组中为众数的那个数就是整个数组的众数。

## ③Boyer-Moore法

```C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int candidate = -1;
        int count = 0;
        for (int num : nums) {
            if (num == candidate)
                ++count;
            else if (--count < 0) {
                candidate = num;
                count = 1;
            }
        }
        return candidate;
    }
};
```

这个是最好的方法，只需要O(n)时间以及O(1)空间

我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；

我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：

如果 x 与 candidate 相等，那么计数器 count 的值增加 1；

如果 x 与 candidate 不等，那么计数器 count 的值减少 1。

# 171题 Excel表列序号

```C++
class Solution {
public:
    int titleToNumber(string columnTitle) {
        int ans = 0;
        int count = 0;
        for(auto beg = columnTitle.rbegin(); beg != columnTitle.rend() ; beg++,count++)//从后往前遍历
        {
            int num = *beg - 'A' + 1;
            num*=pow(26,count);//不是num*=(26*count)!!!
            ans += num;
        }
        return ans;
    }
};
```

没啥难的，我犯错的地方有一个就是ans没初始化为0，导致一直是错误的数字。。。

# 172题 阶乘后的零

```C++
class Solution {
public:
    int trailingZeroes(int n) {
        int ans = 0;
        for (int i = 5; i <= n; i += 5) {
            for (int x = i; x % 5 == 0; x /= 5) {
                ++ans;
            }
        }
        return ans;
    }
};
```

n! 尾零的数量即为 n! 中因子 10 的个数，而 10=2×5，因此转换成求 n! 中质因子 2 的个数和质因子 5 的个数的较小值。

由于质因子 5 的个数不会大于质因子 2 的个数（具体证明见方法二），我们可以仅考虑质因子 5 的个数。

而 n! 中质因子 5 的个数等于 [1,n][1,n] 的每个数的质因子 5 的个数之和，我们可以通过遍历 [1,n][1,n] 的所有 5 的倍数求出。

# 第187题 重复的DNA序列

## ①哈希表 + string滑动窗口

```C++
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        vector<string> ans;
        if(s.size() <= 10) return ans;//小于等于10说明不存在
        unordered_map<string,int> record;
        auto beg = s.begin();
        auto tail = beg + 10;
        for(int i = 0; i < s.size() - 9 ; i++)//注意这里的-9，不是-10，因为size的原因
        {
            string temp(beg,tail);//初始化的用法，tail指向的是尾后
            if(record.count(temp)) record[temp]++;
            else record[temp] = 1;
            beg++,tail++;
        }
        for(auto iter = record.begin() ; iter!=record.end() ; iter++)
        {
            if((*iter).second > 1) ans.push_back((*iter).first);//map的迭代器的iter调用元素用first和second
        }
        return ans;
    }
};
```

思路很简单，就是通过滑动一个10字符大小的窗口来不断记录到哈希表中，最后输出记录次数大于一的即可。

## ②哈希表+字节+滑动窗口

```C++
class Solution {
    const int L = 10;
    unordered_map<char, int> bin = {{'A', 0}, {'C', 1}, {'G', 2}, {'T', 3}};
public:
    vector<string> findRepeatedDnaSequences(string s) {
        vector<string> ans;
        int n = s.length();
        if (n <= L) {
            return ans;
        }
        int x = 0;
        for (int i = 0; i < L - 1; ++i) {
            x = (x << 2) | bin[s[i]];//进2位并把对应字符输入
        }
        unordered_map<int, int> cnt;
        for (int i = 0; i <= n - L; ++i) {
            x = ((x << 2) | bin[s[i + L - 1]]) & ((1 << (L * 2)) - 1);//滑动窗口
            if (++cnt[x] == 2) {
                ans.push_back(s.substr(i, L));
            }
        }
        return ans;
    }
};
```

由于只有四个字符，那么可以将这四个字符转换成2位的bitset，虽然还是需要哈希表，但是存储的元素是整数，不再是字符，能有效的降低空间复杂度和时间复杂度。

# 第188题 买卖股票的最佳时机IV==（未做）==

好难

# 第189题 轮转数组

## ① 额外数组法

```C++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        if(k>nums.size()) k = k % nums.size();
        vector<int> head(nums.begin() , nums.begin() + nums.size() - k);//注意这样初始化的第二个参数是尾后！！
        vector<int> tail(nums.begin() + nums.size() - k, nums.end());
        copy(head.begin(),head.end(),nums.begin() + k);
        copy(tail.begin(),tail.end(),nums.begin());
    }
};
```

利用泛型算法开辟额外数组，之后将额外数组嵌入回原数组即可。

## ②环状替换法

```C++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;
        int count = gcd(k, n);
        for (int start = 0; start < count; ++start) {
            int current = start;
            int prev = nums[start];
            do {
                int next = (current + k) % n;
                swap(nums[next], prev);
                current = next;
            } while (start != current);
        }
    }
};
```

这个就是用一个temp来记录当前元素的值，然后利用数学方法定位到要和他交换的那个数，把那个数和这个数替换，再把temp放到那个数原先的位置。

## ③数组反转法

```C++
class Solution {
public:
    void reverse(vector<int>& nums, int start, int end) {
        while (start < end) {
            swap(nums[start], nums[end]);
            start += 1;
            end -= 1;
        }
    }

    void rotate(vector<int>& nums, int k) {
        k %= nums.size();
        reverse(nums, 0, nums.size() - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.size() - 1);
    }
};
```

| **操作**                                           | **结果**      |
| -------------------------------------------------- | ------------- |
| 原始数组                                           | 1 2 3 4 5 6 7 |
| 翻转所有元素                                       | 7 6 5 4 3 2 1 |
| 翻转 [0, k\bmod n - 1][0,*k*mod*n*−1] 区间的元素   | 5 6 7 4 3 2 1 |
| 翻转 [k\bmod n, n - 1][*k*mod*n*,*n*−1] 区间的元素 | 5 6 7 1 2 3 4 |

# 第190题 颠倒二进制位

## ① bitset string法

```C++
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        bitset<32> b(n);
        string temp = b.to_string();
        reverse(temp.begin(),temp.end());
        bitset<32> b2(temp);
        return b2.to_ulong();
    }
};
```

这里是直接用bitset和string之间的交互做的，很简单。

## ②循环法

```C++
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res = 0;
        for (int i = 0; i < 32; ++i) {
            res = (res << 1) | (n & 1);
            n >>= 1;
        }
        return res;
    }
};
```

创建一个新变量，然后不断左移原来的n，并将n移出来的那位赋予到新变量的右边即可

# 第191题 位1的个数

```C++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ans = 0 ; 
        for(int i = 0; i < 32 ; i++)
        {
            bool last_bit = n & 1;
            n>>=1;
            if(last_bit) ans++;
        }
        return ans;
    }
};
```

很简单，循环右移，然后不断记录最右位是否为1即可。

# 第198题 打家劫舍

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        int choose_this = 0; //如果打劫这家的最大获利
        int not_choose = 0; //不打劫这家的最大获利
        for(auto & n : nums)
        {
            int not_choose_prev = not_choose;
            int choose_prev = choose_this; //由于指针指向了下一家，所以找两个变量暂时记录
            choose_this = max( not_choose_prev + n , choose_prev ); //打劫这家的情况
            not_choose = choose_prev; //不打劫这家，那最大值就是打劫前一家时的最大值。
        }
        return max(choose_this,not_choose);
    }
};
```

很经典的动态规划，但是这个动态规划需要维护两个值，由于有两种情况：

① 不打劫指针遍历到的这家，那么这种情况下能够抢到的最多的钱便是 抢了前面那家时 的最大获利

② 如果打劫指针遍历到的这家，那么能够抢到最多的钱就是 不抢前面那家 + 当前这家 的最大获利

最后从这两个值里面选出最大值就是答案

# 第199题 二叉树的右视图

## ①层次遍历

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;
        if(!root) return ans;
        queue<TreeNode*> q;
        q.push(root);
        while(true)
        {
            int temp_size = q.size();//暂时将当前层的size记录下来
            for(int i = 0 ; i< temp_size;i++)//注意不能直接用q.size()，因为size是在动态变化的
            {
                auto cur = q.front();
                if(i == temp_size - 1) 
                    ans.push_back(cur->val);
                q.pop();
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);

            }
            if(q.empty()) break;
        }
        return ans;
    }
};
```

这个其实时第102题层序遍历的一个应用了，只要找到当前层最末尾的那个元素，输出即可

还有就是这题要看官方题解给的例子才能明白什么意思，题目给的例子不太明显。

## ② 深度遍历

这个比较抽象，而且和之前的通常思路不太一样

# 第200题 岛屿数量

```C++
class Solution {
private:
    void dfs(vector<vector<char>>& grid, int r, int c) {
        int nr = grid.size();
        int nc = grid[0].size();

        grid[r][c] = '0';
        if (r - 1 >= 0 && grid[r-1][c] == '1') dfs(grid, r - 1, c);
        if (r + 1 < nr && grid[r+1][c] == '1') dfs(grid, r + 1, c);
        if (c - 1 >= 0 && grid[r][c-1] == '1') dfs(grid, r, c - 1);
        if (c + 1 < nc && grid[r][c+1] == '1') dfs(grid, r, c + 1);
    }

public:
    int numIslands(vector<vector<char>>& grid) {
        int nr = grid.size();
        if (!nr) return 0;
        int nc = grid[0].size();

        int num_islands = 0;
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    ++num_islands;
                    dfs(grid, r, c);
                }
            }
        }

        return num_islands;
    }
};
```

这题很像第130题 被围绕的区域

需要先编写一个从上下左右深度遍历的函数，要注意的是，这个每次遍历的过程中都会将表格中的1改为0，因为他的遍历虽然在dfs中是不断向深处进发，但是退出来后还是去下一个表格查看是否为1，如果不设为0就会不断循环下去了。

# 第201题 数字范围按位与

```C++
class Solution {
public:
    int rangeBitwiseAnd(int left, int right) {
        int ans = left;
        for(int i = left ; i <= right ; i++)
        {
            ans &= i;
            if(i == INT_MAX || ans == 0) break;
        }
        return ans;
    }
};
```

最蠢的方法就是写一个for循环了，但是会有两个问题，一个是越界一个是超时

超时的话我当时就想到如果答案变为0就没必要继续下去了

虽然这样写了以后没超时，但还是差很多，最好的方法还是要看官方的最长子前缀法。

```C++
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        int shift = 0;
        // 找到公共前缀
        while (m < n) {
            m >>= 1;
            n >>= 1;
            ++shift;
        }
        return m << shift;
    }
};
```

因为只有子前缀在不断与的过程中不会被变成0

# 第202题 快乐数

```C++
class Solution {
public:
    int bitSquareSum(int n) {
        int sum = 0;
        while(n > 0)
        {
            int bit = n % 10;
            sum += bit * bit;
            n = n / 10;
        }
        return sum;
    }
    
    bool isHappy(int n) {
        int slow = n, fast = n;
        do{
            slow = bitSquareSum(slow);
            fast = bitSquareSum(fast);
            fast = bitSquareSum(fast);
        }while(slow != fast);
        
        return slow == 1;
    }
};
```

首先，对于这种可能存在循环的题，都有两种解法

a、哈希表——用哈希表判断这个变量是否出现在先前，如果出现则说明出现循环了

b、快慢指针——一个先走一个后走，如果有循环，则快慢指针必定会相遇

这题还有可能会有一个特殊情况：有没有可能这个数会无限大下去从而不能用上面两个方法检查循环？

可以看官方题解，这个情况是不存在的。

# 第203题 移除链表元素

```C++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* pre = new ListNode(0,head);
        ListNode* newhead_pre = pre;
        while(head)
        {
            if(head->val == val)
            {
                pre->next = head->next;
                auto temp = head->next;
                head->next = nullptr;
                head = temp;
            }
            else
            {
                pre = pre->next;
                head = head->next;
            }
        }
        return newhead_pre->next;
    }
};
```

没啥难的，要注意的就是pre的创建以及newhead的获取

# 第204题 计算质数

## ① 暴力法

```C++
class Solution {
public:
    bool isPrime(int x) {
        for (int i = 2; i * i <= x; ++i) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }

    int countPrimes(int n) {
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            ans += isPrime(i);
        }
        return ans;
    }
};
```

注意这里的暴力并不是每个数都从0~n来计算，这样复杂度就超过O(n^2^)了，而是根据数学知识，了解到因数只会在

0 ~ x^0.5^之间，所以时间复杂度少了一个根号

## ② 统计法

```C++
class Solution {
public:
    int countPrimes(int n) {
        vector<int> isPrime(n, 1);
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            if (isPrime[i]) {
                ans += 1;
                if ((long long)i * i < n) {
                    for (int j = i * i; j < n; j += i) {
                        isPrime[j] = 0;
                    }
                }
            }
        }
        return ans;
    }
};
```

用一个数组当做哈希表，判断这个数是否为质数

从2开始判断，然后不断给2乘一个倍数，把小于等于n中为2的倍数的标记为0,。

如此循环，最后1的个数就是质数的数目

# 第205题 同构字符串

```C++
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        unordered_map<char, char> s2t;
        unordered_map<char, char> t2s;
        int len = s.length();
        for (int i = 0; i < len; ++i) {
            char x = s[i], y = t[i];
            if ((s2t.count(x) && s2t[x] != y) || (t2s.count(y) && t2s[y] != x)) {
                return false;
            }
            s2t[x] = y;
            t2s[y] = x;
        }
        return true;
    }
};
```

没啥好说的，就用哈希表一一对应就完事了



# 第207题 课程表

## ①深度优先

```C++
class Solution {
private:
    vector<vector<int>> edges;//每个节点的边
    vector<int> visited;//判断该节点的状态，0为未访问，1为访问中，2为访问结束
    bool valid = true;

public:
    void dfs(int u) {
        visited[u] = 1;//该节点进入访问状态
        for (int v: edges[u]) {
            if (visited[v] == 0) {//深度优先访问节点
                dfs(v);
                if (!valid) {//有环时
                    return;
                }
            }
            else if (visited[v] == 1) {//深度访问过程中发现了还在访问中的节点，说明有环
                valid = false;
                return;
            }
        }
        visited[u] = 2;//访问结束
    }

    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        edges.resize(numCourses);
        visited.resize(numCourses);
        for (const auto& info: prerequisites) {
            edges[info[1]].push_back(info[0]);//先将有向边全部存入
        }
        for (int i = 0; i < numCourses && valid; ++i) {
            if (!visited[i]) {
                dfs(i);
            }
        }
        return valid;
    }
};
```

这就是图算法中的深度优先判断有没有环的例题，题目中给的课程对应关系其实就像是图矩阵的坐标

这种没有环的图结构称作==拓扑结构==

## ②广度优先搜索

```C++
class Solution {
private:
    vector<vector<int>> edges;
    vector<int> indeg;

public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        edges.resize(numCourses);
        indeg.resize(numCourses);
        for (const auto& info: prerequisites) {//将图的有向边存入
            edges[info[1]].push_back(info[0]);
            ++indeg[info[0]];
        }

        queue<int> q;
        for (int i = 0; i < numCourses; ++i) {
            if (indeg[i] == 0) {//先遍历搜寻入度为0的节点入列
                q.push(i);
            }
        }

        int visited = 0;//访问次数
        while (!q.empty()) {
            ++visited;
            int u = q.front();
            q.pop();
            for (int v: edges[u]) {//广度遍历，并且将遍历的入度数-1
                --indeg[v];
                if (indeg[v] == 0) {//发现新的入度为0的节点
                    q.push(v);
                }
            }
        }

        return visited == numCourses;
    }
};
```

广度优先搜索利用的是队列，而且需要维护每个节点的入度数，这个方法不需要记录访问的状态，只需要记录访问节点的总次数，如果访问的次数和节点的数目不同，说明是有环结构的。

# 第208题 前缀树

```C++
class Trie {
private:
    vector<Trie*> children;//类似树结构的子节点
    bool isEnd;

    Trie* searchPrefix(string prefix) {
        Trie* node = this;//设置node为临时变量
        for (char ch : prefix) {
            ch -= 'a';//存储顺序要减掉字符a
            if (node->children[ch] == nullptr) {//如果这个字符不存在，则说明搜索失败了
                return nullptr;
            }
            node = node->children[ch];//否则继续向子节点搜索
        }
        return node;
    }

public:
    Trie() : children(26), isEnd(false) {}//26个小写字母

    void insert(string word) {
        Trie* node = this;
        for (char ch : word) {
            ch -= 'a';
            if (node->children[ch] == nullptr) {//插入时如果找到没有的后缀则创建新节点
                node->children[ch] = new Trie();
            }
            node = node->children[ch];
        }
        node->isEnd = true;//插入到最后设置flag判断是否为插入节点（isEnd用来判断是否先前插入的节点而不是判断叶节点）
    }

    bool search(string word) {
        Trie* node = this->searchPrefix(word);
        return node != nullptr && node->isEnd;
    }

    bool startsWith(string prefix) {
        return this->searchPrefix(prefix) != nullptr;//这个功能是判断树结构中有无前缀而不是判断是否插入过字符，所以不用isEnd
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```

这题是要设计类的，对我来说比较难，我直接copy官方的答案的

# 第209题 长度最小的子数组

## ①暴力法

没啥好说的，就是用一个会变大的窗口一个一个试，这个时间复杂度是O(N^2^)

## ②二分搜索法

```C++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        vector<int> sums(n + 1, 0); 
        // 为了方便计算，令 size = n + 1 
        // sums[0] = 0 意味着前 0 个元素的前缀和为 0
        // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]
        // 以此类推
        for (int i = 1; i <= n; i++) {
            sums[i] = sums[i - 1] + nums[i - 1];
        }
        for (int i = 1; i <= n; i++) {//还是要一个一个遍历，只是lower_bound是二分搜索的
            int target = s + sums[i - 1];
            auto bound = lower_bound(sums.begin(), sums.end(), target);
            //找到sums[bound] - sums[i-1] > s 的位置
            if (bound != sums.end()) {
                ans = min(ans, static_cast<int>((bound - sums.begin()) - (i - 1)));
            }
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```

说是二分搜索，其实只是在搜索的过程中用到了二分的方法，而非窗口二分

## ③滑动窗口法（双指针）

```C++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            while (sum >= s) {
                ans = min(ans, end - start + 1);
                sum -= nums[start];
                start++;//只有当sum>=s时，start才会向后移
            }
            end++;
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```

只需要N的时间复杂度和1的空间复杂度，方法就是控制两个指针前后移动然后记录下最小的窗口大小

# 第210题 课程表II

```C++
class Solution {
public:
    vector<vector<int>> edges;//用来存储图的边
    vector<int> status;//每个节点的状态，0为未发现，1为访问中，2为访问结束
    vector<int> ans;
    bool ring = false;//用于判断是否存在环结构，存在则输出空数组

    void dfs(vector<int>&cur)//深度搜索当前节点
    {
        for(int i = 0 ; i < cur.size() ; i++)
        {
            if(status[cur[i]] == 2) continue;//已发现则跳过
            if(status[cur[i]] == 1)
            {
                ring = true;
                return;
            }
            status[cur[i]] = 1;//设置为访问中
            dfs(edges[cur[i]]);
            ans.push_back(cur[i]);//注意，这个push一定要在dfs后面而不能在前面！
            status[cur[i]] = 2;//深度搜索结束，设置为访问结束
        }
    }

    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) 
    {
        vector<int> nul;
        edges.resize(numCourses);
        status.resize(numCourses);//设置数组大小
        for(auto&a:prerequisites)
        {
            edges[a[0]].push_back(a[1]);//初始化图结构
        }
        for(int i = 0 ; i < edges.size() ; i++)
        {
            dfs(edges[i]);
            if(ring) return nul;//如果发现存在环结构，则返回空数组
            if(status[i] != 2)
            {
                ans.push_back(i);//dfs该节点的子节点后，需要将其本身进行访问
                status[i] = 2;
            }
        }
        return ans;
    }
};
```

和207题类似，但是需要从中改变一些东西，因为不只是要判断是否存在环。

还有一点就是push环节一定要在dfs的环节后，不然就不能算是深度优先搜索了！

# 第211题 添加与搜索单词

```C++
struct TrieNode{//创建一个字典树结构
    vector<TrieNode *> child;
    bool isEnd;//判断是否到了结尾的标志，这个很重要，否则不能判断之前这里是前缀还是插入的一个词
    TrieNode() {
        this->child = vector<TrieNode *>(26,nullptr);
        this->isEnd = false;
    }
};

void insert(TrieNode * root, const string & word) {//将单词插入树结构
    TrieNode * node = root;
    for (auto c : word) {
        if (node->child[c - 'a'] == nullptr) {
            node->child[c - 'a'] = new TrieNode();
        }
        node = node->child[c - 'a'];
    }
    node->isEnd = true;//最后打上end标记
}

class WordDictionary {
public:
    WordDictionary() {
        trie = new TrieNode();//创建字典树
    }
    
    void addWord(string word) {
        insert(trie,word);
    }
    
    bool search(string word) {
        return dfs(word, 0, trie);
    }

    bool dfs(const string & word,int index,TrieNode * node) {//最重要的递归，index是来判断递归七点的
　　　　if (index == word.size()) {
            return node->isEnd;    
        }
        char ch = word[index];
        if (ch >= 'a' && ch <= 'z') {
            TrieNode * child = node->child[ch - 'a'];
            if (child != nullptr && dfs(word, index + 1, child)) {//将dfs作为判断条件而非return值
                return true;
            }
        } else if (ch == '.') {//如果是"."的话，就要对26个字母进行遍历
            for (int i = 0; i < 26; i++) {
                TrieNode * child = node->child[i];
                if (child != nullptr && dfs(word, index + 1, child)) {
                    return true;
                }
            }
        }
        return false;
    }
private:
    TrieNode * trie;
};
```

这个一开始我自己写的，思路和官方题解差不多，但是在递归DFS那里出现了问题

我写的递归结果默认是返回true，当不匹配的时候返回false，是一种AND类型的递归，但实际上这样是不对的，因为是只要26个字母里存在一个匹配就能够返回true。导致我有一部分答案不能通过

但是这题其实要的递归是默认返回false，当出现匹配的时候返回true，是一种OR类型的递归

还有一个原因是，dfs递归不一定需要作为return，而可以作为判断条件的一部分，我开始拘泥于让dfs放在return的位置，从而导致代码很难写。

最后还有一个原因，我没有设置isEnd这个flag，从而不好判断这个是前缀还是之前插入的值

# 第212题 单词搜索II

```C++
struct TrieNode//字典树结构
{
    vector<TrieNode*> children;
    bool isEnd;
    TrieNode():children(26),isEnd(false){};//构造函数
    void insert(vector<string>&);//插入字典树
};

void TrieNode::insert(vector<string> & words)
{
    for(auto & w:words)
    {
        auto pointer = this;
        for(int i = 0 ; i < w.size() ; i++)
        {
            int index = w[i] - 'a';
            if(!pointer->children[index])
                pointer->children[index] = new TrieNode();//必须要先if判断！！！不然本来isEnd是true的被初始化成false了！，而且如果先插入oaa再插入oa，就导致第二个a不见了！
            pointer = pointer->children[index];
            if(i == w.size() - 1) pointer->isEnd = true;//到达了末尾则设置为end
        }
    }
}

class Solution {
public:
    TrieNode* T;//创建一个空的字典树，记得要带*，是要指针
    vector<string> ans;
    string path;//递归路径上的字符

    void dfs(vector<vector<char>>& board , TrieNode*T ,int i ,int j,vector<vector<bool>>&isVisted)
    {
        if(i<0 || j<0 || i>=board.size() || j>=board[0].size() || isVisted[i][j] == true) return;//判断是否还需要递归
        int index = board[i][j] - 'a';
        if(T->children[index])
        {
            isVisted[i][j] = true;
            path.push_back(board[i][j]);
            if(T->children[index]->isEnd == true) 
            {
                ans.push_back(path);
                T->children[index]->isEnd = false;
            }
            
            dfs(board,T->children[index],i + 1 , j ,isVisted);//向四个方向进行滤波
            dfs(board,T->children[index],i - 1 , j ,isVisted);
            dfs(board,T->children[index],i , j - 1 ,isVisted);
            dfs(board,T->children[index],i , j + 1 ,isVisted);
            
            isVisted[i][j] = false;
            path.pop_back();//递归结束后，要返回原来的状态
        }          
    }

    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        T = new TrieNode();//初始化字典树
        T->insert(words);
        vector<vector<bool>> isVisted(board.size(),vector<bool>(board[0].size(),false));//初始化访问数组
        for(int i = 0; i<board.size() ; i++)
            for(int j = 0; j<board[0].size() ; j++)
            {
                dfs(board,T,i,j,isVisted);//对每一个点都进行深度遍历
            }
        return ans;
    }
};
```

这个就是一个综合考察，对深度优先搜索DFS和字典树的综合考察。

其他的难点有：二维数组的初始化，isEnd的设定以及改变

# 第213题 打家劫舍II

```C++
class Solution {
public:
    int robRange(vector<int>& nums, int start, int end) {
        int first = nums[start], second = max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            int temp = second;
            second = max(first + nums[i], second);
            first = temp;
        }
        return second;
    }

    int rob(vector<int>& nums) {
        int length = nums.size();
        if (length == 1) {
            return nums[0];
        } else if (length == 2) {
            return max(nums[0], nums[1]);
        }
        return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));//点睛之笔
    }
};
```

这题的方法其实和第198题是一样的，但是由于首尾相连，不能直接套用，于是直接不考虑首和尾即可

我一开始用了很多的条件判断，比如选择了第2个元素和是否选择了倒数第二个元素，但是发现这样做要判断的太多了

官方的这个方法十分好，直接分别排除首尾元素的影响然后取最大值

# 第214题 最短回文串

```C++
class Solution {
public:
    string shortestPalindrome(string s) {
        int n = s.size();
        vector<int> fail(n, -1);
        for (int i = 1; i < n; ++i) {//构建next表
            int j = fail[i - 1];
            while (j != -1 && s[j + 1] != s[i]) {
                j = fail[j];
            }
            if (s[j + 1] == s[i]) {
                fail[i] = j + 1;
            }
        }
        int best = -1;
        for (int i = n - 1; i >= 0; --i) {//逆序匹配，这段太抽象了
            while (best != -1 && s[best + 1] != s[i]) {
                best = fail[best];
            }
            if (s[best + 1] == s[i]) {
                ++best;
            }
        }
        string add = (best == n - 1 ? "" : s.substr(best + 1, n));
        reverse(add.begin(), add.end());
        return add + s;
    }
};
```

这个难点在于怎么减少时间复杂度，一开始很容易想到找到最长的前缀回文串即可，但是一个一个字符判断是否为回文串很容易超时。

于是就想到了用KMP算法，将字符串反转匹配，具体还是要看官方答案，讲的很好，顺便能复习一下KMP

# 第215题 数组中的第K大的元素

这题在数据结构教材中有提过，但是这里给出了三个方法：

前两个方法的思路[『 TopK问题 』快速排序、堆排序详解 - 数组中的第K个最大元素 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/by-flix-amc8/)

## ① 快速排序算法

```C++
class Solution {
public:
    int quickSelect(vector<int>& a, int l, int r, int index) {
        int q = randomPartition(a, l, r);//将l到r的数组进行快速排序
        if (q == index) {//如果q正好是第index个值，直接返回
            return a[q];
        } else {//否则递归排序
            return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);
        }
    }

    inline int randomPartition(vector<int>& a, int l, int r) {//对l到r进行排序的函数
        int i = rand() % (r - l + 1) + l;//随机选取一个在l到r之间的数
        swap(a[i], a[r]);//将其和末尾交换
        return partition(a, l, r);
    }

    inline int partition(vector<int>& a, int l, int r) {
        int x = a[r], i = l - 1;
        for (int j = l; j < r; ++j) {
            if (a[j] <= x) {
                swap(a[++i], a[j]);//进行快速排序
            }
        }
        swap(a[i + 1], a[r]);
        return i + 1;
    }

    int findKthLargest(vector<int>& nums, int k) {
        srand(time(0));
        return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);
    }
};
```

## ②堆排序算法

a、采用C++内置的优先级队列

维护一个长度为k的优先队列，并从小到大排列，如果新元素比头部元素大，头部元素不再是前k大，弹出，不断更新即可，最后头元素即是第k大。

```C++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<>> q;
        for (const auto &num: nums) {
            if (q.size() < k) {
                q.push(num);
            } else if (q.top() < num) { //num如果比qtop要大，说明top不是第前k大
                q.pop();
                q.push(num);
            }
        }
        return q.top();
    }
};
```

b、自建小根堆

```C++
class Solution {
   public:
    int findKthLargest(vector<int>& nums, int k) {
        // 对前k个元素建成小根堆
        for (int i = 0; i < k; i++) {
            swim(nums, i);
        }
        // 剩下的元素与堆顶比较，若大于堆顶则去掉堆顶，再将其插入
        for (int i = k; i < nums.size(); i++) {
            if (nums[i] > nums[0]) {
                swap(nums[0], nums[i]);
                sink(nums, 0, k - 1);
            }
        }
        // 结束后第k个大的数就是小根堆的堆顶
        return nums[0];
    }

   private:
    // 若v1比v2优先度高，返回true
    bool priorityThan(int v1, int v2) { return v1 < v2; }

    // 上浮 从下到上调整堆
    void swim(vector<int>& heap, int i) {
        while (i > 0 && priorityThan(heap[i], heap[(i - 1) / 2])) {
            swap(heap[i], heap[(i - 1) / 2]);
            i = (i - 1) / 2;
        }
    }

    // 下沉 从上到下调整堆
    void sink(vector<int>& heap, int i, int N) {
        while (2 * i + 1 <= N) {
            int j = 2 * i + 1;
            if (j + 1 <= N && priorityThan(heap[j + 1], heap[j])) {
                j++;
            }
            if (priorityThan(heap[i], heap[j])) {
                break;
            }
            swap(heap[i], heap[j]);
            i = j;
        }
    }
};
```

## ③基数排序法

这个能够使用完全是因为题目给的是整数

# 第216题 组合总数III

```C++
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;
    void dfs(int k, int n ,int start)
    {
        if(k == 0 && n != 0 ) return;//回溯中止条件
        if(k == 0 && n==0)
        {
            ans.push_back(path);
            return;
        }
        for(int i = start ; i <= 9 ; i++)//注意只能从1-9中选取，而不是1-n
        {
            path.push_back(i);
            dfs(k-1,n-i,i + 1);//将先前选出的数字排除，并减少需要的数字量
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) 
    {
        dfs(k,n,1);
        return ans;
    }
};
```

经典的回溯题，每次回溯都要将参数变小，从而筛选出符合条件的答案。

# 第217题 存在重复元素

```C++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        for (int i = 0; i < n - 1; i++) {
            if (nums[i] == nums[i + 1]) {
                return true;
            }
        }
        return false;
    }
};
```

没有什么特别的技巧，很无聊的题

# 第218题 天际线问题

[优先队列 + 延迟删除技巧（Java） - 天际线问题 - 力扣（LeetCode）](https://leetcode.cn/problems/the-skyline-problem/solution/you-xian-dui-lie-java-by-liweiwei1419-jdb5/)

这个答案是最好的，通过扫描和分类判断这个点是否该列入天际线节点

# 第219题 存在重复元素II

```c++
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        if(!k) return false; //k==0时必定不可能存在
        map<int,int> m;
        for(int i = 0;i<nums.size();i++)
        {
            if(m.size()<k)
            {
                if(m.count(nums[i])) return true;
                m[nums[i]] = 1;
                continue;
            }
            if(m.count(nums[i])) return true;
            else 
            {
                m.erase(nums[i - k]);
                m[nums[i]] = 1;
            }
        }
        return false;
    }
};
```

这个用map就可以搞定

# 第220题 存在重复元素III

```C++
//set版
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        int n = nums.size();
        set<int> rec;
        for (int i = 0; i < n; i++) {
            auto iter = rec.lower_bound(max(nums[i], INT_MIN + t) - t);
            if (iter != rec.end() && *iter <= min(nums[i], INT_MAX - t) + t) {
                return true;
            }
            rec.insert(nums[i]);
            if (i >= k) {
                rec.erase(nums[i - k]);
            }
        }
        return false;
    }
};

//map版
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        int n = nums.size();
        map<int,int> rec;
        for (int i = 0; i < n; i++) {
            auto iter = rec.lower_bound(max(nums[i], INT_MIN + t) - t);
            if (iter != rec.end() && iter->first <= min(nums[i], INT_MAX - t) + t) {
                return true;
            }
            rec[nums[i]] = 1;
            if (i >= k) {
                rec.erase(nums[i - k]);
            }
        }
        return false;
    }
};
```

set和map都是可以的，但是map有点多余，这题不需要用到key，因为每次记录key的value都是相同的值1，所以可以直接用set来进行修改。

而set和map是有序容器，内部的数据结构是二叉树，这题又要维护一个有序的结构，所以set和map是最好的选择
