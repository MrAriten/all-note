# LINUX高性能服务器编程

# 第一章 TCP/IP协议簇

 

数据链路层——ARP，RARP协议——网络地址与物理地址的转换
网络层——IP，ICMP协议——根据数据包的目的IP地址来决定如何投递它
传输层——TCP，UDP，SCTP协议——传输层则为应用程序封装了一条端到端的逻辑通信链路，它负责数据的收发、链路的超时重连

## 应用层：

ping是应用程序，而不是协议，其利用ICMP报文检测网络连接，是调试网络环境的必备工具。
telnet协议是一种远程登录协议，它使我们能在本地完成远程任务。
OSPF（Open Shortest Path First，开放最短路径优先）协议是一种 动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由 信息。
DNS（Domain Name Service，域名服务）协议提供机器域名到IP地址的转换。

## 封装：

经过TCP封装后的数据称为TCP报文段，经过UDP封装后的数据称为UDP数据报，经过IP封装后的数据称为IP数据报，经过数据链路层封装的数据称为帧。

## 分用：

当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用 （demultiplexing）。

因为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的 头部需要提供某个字段（具体情况取决于帧的类型）来区分它们。

如果主机接收到的以太网帧类型字段的值为0x800，则帧的数据部分为IP数据报
为0x806，则帧的数据部分为ARP请求或应答报文，以太网驱 动程序就将帧交付给ARP模块
为0x835，则帧的数据 部分为RARP请求或应答报文，以太网驱动程序就将帧交付给RARP模 块。

![图1-7 分用](C:\Users\Administrator\Desktop\笔记\llinux服务器\图1-7 分用.png)

## ARP协议原理

ARP协议能实现任意网络层地址到任意物理地址的转换，不过本书仅讨论从IP地址到以太网地址（MAC地址）的转换。其工作原理 是：==主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络上的其他机器都将收到这个请求，但只有被请求 的目标机器会回应一个ARP应答，其中包含自己的物理地址==

### ARP的高速缓存

ARP维护一个高速缓存，其中包含经常访问（比如网关地址）或最近访问的机器的IP地址到物理地址的映射。这样就避免了重 复的ARP请求，提高了发送数据包的速度。

```bash
arp -a #查看和修改ARP缓存
#输出
Kongming20(192.168.1.109)at 08:00:27:53:10:67[ether]on eth0 #kongming20地址
?(192.168.1.1)at 14:e6:e4:93:5b:78[ether]on eth0 #路由器地址
```

其中，第一项描述的是另一台测试机器Kongming20（注意，其IP 地址、MAC地址都与图1-8描述的一致），第二项描述的是路由器。

![图1-8 测试网络]([\llinux服务器\图1-8 测试网络.png](https://github.com/MrAriten/all-note/blob/main/LINUX%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/llinux%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%9B%BE1-8%20%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C.png))

下面两条命令则分别删除和添加一个ARP缓存项：

```bash
arp -d 192.168.179.2
arp -s 192.168.179.2 00:50:56:ee:2c:7d
```

### 使用tcpdump观察ARP通信

```bash
sudo arp-d 192.168.1.109
sudo tcpdump -i eth0 -ent '(dst 192.168.1.109 and src 192.168.1.108)or(dst 192.168.1.108 and src 192.168.1.109)'
#课本上没空格，实际这些东西都要用空格分开的，否则会报错
telnet 192.168.1.109 echo#开启另一个终端执行telnet命令，telnet用于远程连接另一台主机并操控他
```

### tcpdump命令：

```
	-a 　　　将网络地址和广播地址转变成名字；
　　　-d 　　　将匹配信息包的代码以人们能够理解的汇编格式给出；
　　　-dd 　　　将匹配信息包的代码以c语言程序段的格式给出；
　　　-ddd 　　　将匹配信息包的代码以十进制的形式给出；
　　　-e 　　　在输出行打印出数据链路层的头部信息，包括源mac和目的mac，以及网络层的协议；
　　　-f 　　　将外部的Internet地址以数字的形式打印出来；
　　　-l 　　　使标准输出变为缓冲行形式；
　　　-n 　　　指定将每个监听到数据包中的域名转换成IP地址后显示，不把网络地址转换成名字；
     -nn：    指定将每个监听到的数据包中的域名转换成IP、端口从应用名称转换成端口号后显示
　　　-t 　　　在输出的每一行不打印时间戳；
　　　-v 　　　输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息；
　　　-vv 　　　输出详细的报文信息；
　　　-c 　　　在收到指定的包的数目后，tcpdump就会停止；
　　　-F 　　　从指定的文件中读取表达式,忽略其它的表达式；
　　　-i 　　　指定监听的网络接口；
      -p：    将网卡设置为非混杂模式，不能与host或broadcast一起使用
　　　-r 　　　从指定的文件中读取包(这些包一般通过-w选项产生)；
　　　-w 　　　直接将包写入文件中，并不分析和打印出来；
     -s snaplen         snaplen表示从一个包中截取的字节数。0表示包不截断，抓完整的数据包。默认的话 tcpdump 只显示部分数据包,默认68字节。
　　　-T 　　　将监听到的包直接解释为指定的类型的报文，常见的类型有rpc （远程过程调用）和snmp（简单网络管理协议；）
      -X            告诉tcpdump命令，需要把协议头和包内容都原原本本的显示出来（tcpdump会以16进制和ASCII的形式显示），这在进行协议分析时是绝对的利器。
```

在执行telnet命令之前，应先清除ARP缓存中与Kongming20对应的 项，否则ARP通信不被执行，我们也就无法抓取到期望的以太网帧。

执行telnet命令并在两台通信主机之间建立TCP连接后（telnet输 出“Connected to 192.168.1.109”），输入Ctrl+]以调出telnet程序的命令提 示符，然后在telnet命令提示符后输入quit，退出telnet客户端程序（因 为ARP通信在TCP连接建立之前就已经完成，故我们不关心后续内 容）。

### tcpdump监听到的数据包：

```bash
00:16:d3:5c:b9:e3＞ff:ff:ff:ff:ff:ff,ethertype ARP(0x0806),length 42:Request who-has 192.168.1.109 tell 192.168.1.108,length 28
08:00:27:53:10:67＞00:16:d3:5c:b9:e3,ethertype ARP(0x0806),length 60:Reply 192.168.1.109 is-at 08:00:27:53:10:67,length 46
#由tcpdump抓取的数据包本质上是以太网帧，我们通过该命令的众多选项来控制帧的过滤（比如用dst和src指定通信的目的端IP地址和源端IP地址）和显示（比如用-e选项开启以太网帧头部信息的显示）。
```

![图1-10 ARP通信过程](C:\Users\Administrator\Desktop\笔记\llinux服务器\图1-10 ARP通信过程.png)

ARP请求和应答是从以太网驱动程序发出的，而==并非像图中描述的那样从ARP模块直接发送到以太网上==，所以我们将它们用虚线表示，这主要是为了体现携带ARP数据的以太网帧和其他以太网帧 （比如携带IP数据报的以太网帧）的区别。

路由器也将接收到以太网帧1，==因为该帧是一个广播帧==。不过很显然，路由器并没有回应其中的ARP请求

==ernest向kongming发送ARP请求==

## DNS工作原理

DNS是一套分布式的域名服务系统。每个DNS服务器上都存放着 大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端 程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。

### linux下的DNS服务器

Linux 使用==/etc/resolv.conf==文件来存放DNS服务器的IP地址。机器ernest-laptop 上，该文件的内容如下：

```
#Generated by Network Manager
nameserver 219.239.26.42
nameserver 124.207.160.106
```

### linux访问DNS服务

```bash
$host -t A www.baidu.com
www.baidu.com is an alias for www.a.shifen.com.
www.a.shifen.com has address 119.75.217.56
www.a.shifen.com has address 119.75.218.77
```

host命令的输出告诉我们，机器名www.baidu.com是 www.a.shifen.com的别名且该机器名对应两个IP地址。
host命令使用DNS协议和DNS服务器通信

### 使用tcpdump观察DNS通信

```bash
sudo tcpdump -i eth0 -nt -s 500 port domain
host-t A www.baidu.com #要分开执行！！分开两个终端！！
```

输出如下

```
1.IP 192.168.1.108.34319＞219.239.26.42.53:57428+A?www.baidu.com.
(31)
2.IP 219.239.26.42.53＞192.168.1.108.34319:57428 3/4/4 CNAME
www.a.shifen.com.,A 119.75.218.77,A 119.75.217.56(226)
```

这两个数据包开始的“IP”指出，它们后面的内容描述的是==IP数据报==。tcpdump以“IP地址.端口号”的形式来描述通信的某一端；以“＞”表 示数据传输的方向，“＞”前面是源端，后面是目的端。

第一个 数据包是测试机器ernest-laptop（IP地址是192.168.1.108）==向其首选DNS 服务器（IP地址是219.239.26.42）发送的DNS查询报文==（目标端口53是 DNS服务使用的端口，这一点我们在前面介绍过），第二个数据包是==服务器反馈的DNS应答报文。==

## socket和TCP/IP协议的关系

数据链路层、网络层、传输层协议是==在内核中实现的==。因此操作系统需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。

实现这组系统调用的API就是socket

socket的两个功能：
一是将应用程序数 据从用户缓冲区中复制到TCP/UDP内核发送缓冲区，以交付内核来发送数据（比如图1-5所示的send函数），或者是从内核TCP/UDP接收缓冲区中复制数据到用户缓冲区，以读取数据。
二是应用程序可以通过 它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精 细地控制底层通信的行为。比如可以通过setsockopt函数来设置IP数据 报在网络上的存活时间。

# 第二章 IP协议详解

IP协议是TCP/IP协议族的动力，它为上层协议提供==无状态、无连接、不可靠==的服务。

无状态（stateless）是指IP通信双方不同步传输数据的状态信息， 因此所有IP数据报的发送、传输和接收都是==相互独立、没有上下文关系==的。接收端的IP模块只要收到了完整的IP 数据报（如果是IP分片的话，IP模块将先执行重组），就将其数据部 分（TCP报文段、UDP数据报或者ICMP报文）上交给上层协议。那么 从上层协议来看，这些数据就可能是乱序的、重复的。面向连接的协 议，比如TCP协议，则能够自己处理乱序的、重复的报文段，它递交 给上层协议的内容绝对是有序的、正确的。

无连接（connectionless）是指IP通信双方都不长久地维持对方的 任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对 方的IP地址。

不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是 承诺尽最大努力（best effort）。

## IPv4头部结构

### 服务类型

8位服务类型（Type Of Service，TOS）包括一个3位的优先权字段 （现在已经被忽略），4位的TOS字段和1位保留字段（必须置0）。4位 的TOS字段分别表示：==最小延时，最大吞吐量，最高可靠性和最小费用。其中最多有一个能置为1，==应用程序应该根据实际需要来设置它。 比如像ssh和telnet这样的登录程序需要的是最小延时的服务，而文件传 输程序ftp则需要最大吞吐量的服务。

### 使用tcpdump观察IPV4头部结构

```bash
$sudo tcpdump-ntx-i lo#抓取本地回路上的数据包
$telnet 127.0.0.1#开启另一个终端执行telnet命令登录本机
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is'^]'.
Ubuntu 9.10
ernest-laptop login:ernest#输入用户名并回车
Password:#输入密码并回车
```

输出

```
IP 127.0.0.1.41621＞127.0.0.1.23:Flags[S],seq 3499745539,win 32792,
options[mss 16396,sackOK,TS val 40781017 ecr 0,nop,wscale 6],length 0
0x0000:4510 003c a5da 4000 4006 96cf 7f00 0001
0x0010:7f00 0001 a295 0017 d099 e103 0000 0000
0x0020:a002 8018 fe30 0000 0204 400c 0402 080a
0x0030:026e 44d9 0000 0000 0103 0306
```

该数据包描述的是一个IP数据报。由于我们是使用telnet登录本机 的，所以IP数据报的源端IP地址和目的端IP地址都是“127.0.0.1”。

## IP分片

==当IP数据报的长度超过帧的MTU时，它将被分片传输。==分片可能发生在发送端，也可能发生在中转路由器上，而且可能在传输过程中被多次分片，但只有在最终的目标机器上，这些分片才会被内核中的IP模块重新组装

以太网帧的MTU是1500字节（可以通过ifconfig命令或者netstat命 令查看），因此它携带的IP数据报的数据部分最多是1480字节（IP头部 占用20字节）。考虑用IP数据报封装一个长度为1481字节的ICMP报文 （包括8字节的ICMP头部，所以其数据部分长度为1473字节），则该 数据报在使用以太网帧传输时必须被分片

![图2-2 携带ICMP报文的IP数据报被分片](C:\Users\Administrator\Desktop\笔记\llinux服务器\图2-2 携带ICMP报文的IP数据报被分片.png)

### 使用tcpdump观察分片

```bash
sudo tcpdump-ntv-i eth0 icmp#只抓取ICMP报文
ping Kongming20-s 1473#用-s选项指定每次发送1473字节的数据
```

输出

```
IP(tos 0x0,ttl 64,id 61197,offset 0,flags[+],proto ICMP(1),length 1500)192.168.1.108＞192.168.1.110:ICMP echo
request,id 41737,seq 1,length 1480
IP(tos 0x0,ttl 64,id 61197,offset 1480,flags[none],proto ICMP(1),length 21)192.168.1.108＞192.168.1.110:icmp
```

这两个IP分片的标识值都是61197，说明它们是同一个IP数据报的 分片。第一个分片的片偏移值为0，而第二个则是1480。很显然，第二 个分片的片偏移值实际上也是第一个分片的ICMP报文的长度。

## IP路由

### IP模块的工作流程

![图2-3 IP模块基本工作流程](C:\Users\Administrator\Desktop\笔记\llinux服务器\图2-3 IP模块基本工作流程.png)

### 路由机制

#### 查看路由表的内容

```bash
route #linux命令
#输出
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
default 192.168.1.1 0.0.0.0 UG 0 0 0 eth0
192.168.1.0*255.255.255.0 U 1 0 0 eth0
```

![表2-2 路由表含义](C:\Users\Administrator\Desktop\笔记\llinux服务器\表2-2 路由表含义.png)

### 路由表更新

```bash
$sudo route add-host 192.168.1.109 dev eth0 #添加主机192.168.1.109对应的路由项eth0
$sudo route del-net 192.168.1.0 netmask 255.255.255.0 #删除网络192.168.1.0对应的路由项
$sudo route del default#删除默认路由项，这样做的后果是无法访问因特网
$sudo route add default gw 192.168.1.109 dev eth0#重新设置默认路由项，不过这次其网关是机器Kongming20
```

## IP转发

不是发送给本机的IP数据报将由数据报转发子模块来 处理。路由器都能执行数据报的转发操作

==而主机一般只发送和接收数据报==，这是因为主机上/proc/sys/net/ipv4/ip_forward内核参数默认被 设置为0。

## 重定向

![图2-5 主机重定向过程](C:\Users\Administrator\Desktop\笔记\llinux服务器\图2-5 主机重定向过程.png)

Kongming20给ernest-laptop发送了一个 ICMP重定向报文，告诉它请通过192.168.1.1来访问目标机器，因为这 对ernest-laptop来说是更合理的路由方式。当主机ernest-laptop收到这样 的ICMP重定向报文后，它将更新其路由表缓冲（使用命令route-Cn查 看），并使用新的路由方式来发送后续数据报。

# 第三章 TCP协议详解

传输层协议主要有两个：TCP协议和UDP协议。TCP协议相对于 UDP协议的特点是：==面向连接、字节流和可靠传输。==

使用TCP协议通信的双方必须==先建立连接==，然后才能开始数据的读写。双方都必须为该连接==分配必要的内核资源==，以管理连接的状态和 连接上数据的传输。TCP连接是==全双工的==，即双方的数据读写可以通过 一个连接进行。完成数据交换之后，通信双方都必须断开连接以释放系统资源。

TCP协议的这种连接是一对一的，所以==基于广播和多播（目标是多 个主机地址）的应用程序不能使用TCP服务。==而无连接协议UDP则非常 适合于广播和多播。

字节流服务和数据报服务的区别：对应到实际编程中，则体现为通信双方是否必须执行相同次数的 读、写操作（当然，这只是表现形式）。接收端收到一个或多个TCP报文段后，TCP模块将它们携带的应 用程序数据按照TCP报文段的序号（见后文）依次放入TCP接收缓冲区 中，并通知应用程序读取数据。接收端应用程序可以一次性将TCP接收 缓冲区中的数据全部读出，也可以分多次读取，这取决于用户指定的 应用程序读缓冲区的大小。因此，应用程序执行的读操作次数和TCP模 块接收到的TCP报文段个数之间也没有固定的数量关系。

==综上所述，发送端执行的写操作次数和接收端执行的读操作次数 之间没有任何数量关系，这就是字节流的概念==

UDP则不然。发送端应用程序每执行一 次写操作，UDP模块就将其封装成一个UDP数据报并发送之。接收端 必须及时针对每一个UDP数据报执行读操作（通过recvfrom系统调 用），否则就会丢包（这经常发生在较慢的服务器上）。并且，如果 用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将 被截断。

<img src="C:\Users\Administrator\Desktop\笔记\llinux服务器\图3-1 图3-2 TCP字节流服务 UDP数据报服务.png" alt="图3-1 图3-2 TCP字节流服务 UDP数据报服务" style="zoom:67%;" />

## TCP的头部

P90有详细信息

### 利用tcpdump观察TCP头部信息

之前观察的IP数据报，就包含了TCP头部信息，从第21个字节开始

```
IP 127.0.0.1.41621＞127.0.0.1.23:Flags[S],seq 3499745539,win 32792,
options[mss 16396,sackOK,TS val 40781017 ecr 0,nop,wscale 6],length 0
0x0000:4510 003c a5da 4000 4006 96cf 7f00 0001
0x0010:7f00 0001 a295 0017 d099 e103 0000 0000
0x0020:a002 8018 fe30 0000 0204 400c 0402 080a
0x0030:026e 44d9 0000 0000 0103 0306
```

tcpdump输出Flags[S]，表示该TCP报文段包含SYN标志，因此它是 一个同步报文段。如果TCP报文段包含其他标志，则tcpdump也会将该 标志的首字母显示在“Flags”后的方括号中。

seq是序号值。因为该同步报文段是从127.0.0.1.41621（客户端IP地 址和端口号）到127.0.0.1.23（服务器IP地址和端口号）这个传输方向 上的第一个TCP报文段，所以这个序号值也就是此次通信过程中该传输 方向的ISN值。并且，因为这是整个通信过程中的第一个TCP报文段， 所以它没有针对对方发送来的TCP报文段的确认值

win是接收通告窗口的大小。因为这是一个同步报文段，所以win 值反映的是实际的接收通告窗口大小。

options是TCP选项，其具体内容列在方括号中。
mss是发送端（客 户端）通告的最大报文段长度。通过ifconfig命令查看回路接口的MTU 为16436字节，因此可以预想到TCP报文段的MSS为16396（16436-40） 字节。
sackOK表示发送端支持并同意使用SACK选项。
TS val是发送端 的时间戳。ecr是时间戳回显应答。因为这是一次TCP通信的第一个 TCP报文段，所以它针对对方的时间戳的应答为0（尚未收到对方的时 间戳）。
紧接着的nop是一个空操作选项。wscale指出发送端使用的窗口扩大因子为6。

## tcpdump观察TCP的连接建立

```bash
$sudo tcpdump -i eth0 -nt '(src 192.168.1.109 and dst192.168.1.108)or(src 192.168.1.108 and dst 192.168.1.109)'
$telnet 192.168.1.109 80
```

```bash
#3握手
1.IP 192.168.1.108.60871＞192.168.1.109.80:Flags[S],seq 535734930,win 5840,length 0
2.IP 192.168.1.109.80＞192.168.1.108.60871:Flags[S.],seq 2159701207,ack 535734931,win 5792,length 0
3.IP 192.168.1.108.60871＞192.168.1.109.80:Flags[.],ack 1,win 92,length 0
#4挥手
4.IP 192.168.1.108.60871＞192.168.1.109.80:Flags[F.],seq 1,ack 1,win 92,length 0
5.IP 192.168.1.109.80＞192.168.1.108.60871:Flags[.],ack 2,win 91,length 0
6.IP 192.168.1.109.80＞192.168.1.108.60871:Flags[F.],seq 1,ack 2,win 91,length 0
7.IP 192.168.1.108.60871＞192.168.1.109.80:Flags[.],ack 2,win 92,length 0
```

因为整个过程并没有发生应用层数据的交换，所以TCP报文段的数据部分的长度（length）总是0。

<img src="C:\Users\Administrator\Desktop\笔记\llinux服务器\图3-6 TCP连接的建立和关闭时序图.png" alt="图3-6 TCP连接的建立和关闭时序图" style="zoom:67%;" />

## 在linux上观察连接超时

```bash
#模拟繁忙的服务器
$sudo iptables -F
$sudo iptables -I INPUT -p tcp --syn -i eth0 -j DROP
#iptable命令用于过滤数据包，这里我们利用它来丢弃所有接收到的连接请求（丢弃所有同步报文段，这样客户端就无法得到任何确认报文段）
```

然后用相同的方法观察数据报

```bash
1.21:23:35.612136 IP 192.168.1.109.39385＞
192.168.1.108.telnet:Flags[S],seq 1355982096，length 0
2.21:23:36.613146 IP 192.168.1.109.39385＞
192.168.1.108.telnet:Flags[S],seq 1355982096,length 0
3.21:23:38.617279 IP 192.168.1.109.39385＞
192.168.1.108.telnet:Flags[S],seq 1355982096,length 0
4.21:23:42.625140 IP 192.168.1.109.39385＞
192.168.1.108.telnet:Flags[S],seq 1355982096,length 0
5.21:23:50.641344 IP 192.168.1.109.39385＞
192.168.1.108.telnet:Flags[S],seq 1355982096,length 0
6.21:24:06.673331 IP 192.168.1.109.39385＞
192.168.1.108.telnet:Flags[S],seq 1355982096,length 0
```

我们一共抓取到6个TCP报文段，它们都是同步报文段，并且具有 相同的序号值，这说明后面5个同步报文段都是超时重连报文段。观察 这些TCP报文段被发送的时间间隔，它们分别为1s、2s、4s、8s和 16s（由于定时器精度的问题，这些时间间隔都有一定偏差），可以推 断最后一个TCP报文段的超时时间是32s（63s-16s-8s-4s-2s-1s）。因 此，TCP模块一共执行了5次重连操作，这是由/proc/sys/net/ipv4/tcp_syn_retries内核变量所定义的。

## TCP状态转移

![图3-8 TCP的状态转移过程](C:\Users\Administrator\Desktop\笔记\llinux服务器\图3-8 TCP的状态转移过程.png)

==CLOSED是一个假想的起始点，并不是一个实际的状态。==

### 连接建立失败的情况

客户端通过connect系统调用（见第5章）主动与服务器建立连接。 connect系统调用首先给服务器发送一个同步报文段，使连接转移到 SYN_SENT状态。此后，connect系统调用可能因为如下两个原因失败返回：

❑如果connect连接的==目标端口不存在==（未被任何进程监听），或者==该端口仍被处于TIME_WAIT状态的连接所占用==（见后文），则服务 器将给客户端发送一个复位报文段，connect调用失败。
❑如果目标端口存在，但connect在==超时==时间内未收到服务器的确认报文段，则connect调用失败。

connect调用失败将使连接立即返回到初始的CLOSED状态。

### 连接关闭失败的情况

如果不是为了在半关闭状态下继续接收数据，连接长时间地停留 在FIN_WAIT_2状态并无益处。连接停留在FIN_WAIT_2状态的情况可 能发生在：

客户端执行半关闭后，未等服务器关闭连接就强行退出了。此时客户端连接由内核来接管，可称之为==孤儿连接==

### TIME_WAIT状态

有时候我们希望避免TIME_WAIT状态，因为当程序退出后，我们 希望能够立即重启它。但由于处在TIME_WAIT状态的连接还占用着端 口，程序将无法启动。

## 复位报文段

在某些特殊条件下，TCP连接的一端会向另一端发送携带RST标 志的报文段，即复位报文段，以通知对方关闭连接或重新建立连接。

考虑从Kongming20上执行telnet命令登录ernest-laptop上一个==不存在的54321端口==，并用tcpdump抓取该过程中 两台主机交换的TCP报文段。

得到如下IP数据报：

```bash
1.IP 192.168.1.109.42001＞192.168.1.108.54321:Flags[S],seq 21621375,win 14600,length 0
2.IP 192.168.1.108.54321＞192.168.1.109.42001:Flags[R.],seq 0,ack 21621376,win 0,length 0
```

回应了一个复位报文段==（tcpdump输出R标志）==。因为复位报文段 的接收通告窗口大小为0，所以可以预见：收到复位报文段的一端应该 关闭连接或者重新连接，而不能回应这个复位报文段。

### 异常终止连接

数据交换完成之 后，一方给另一方发送结束报文段。TCP提供了异常终止一个连接的 方法，即给对方发送一个复位报文段。==一旦发送了复位报文段，发送 端所有排队等待发送的数据都将被丢弃。==

### 半打开连接

服务器（或客户端）关闭或者异常终止了连接，而对方没有接收到结束报文段（比如发生了网络故障），此时， 客户端（或服务器）还维持着原来的连接，而服务器（或客户端）即 使重启，也已经没有该连接的任何信息了。我们将这种状态称为半打开状态，处于这种状态的连接称为半打开连接。

举例来说，我们在Kongming20上使用nc命令模拟一个服务器程序，使之监听12345端口，然后从ernest-laptop运行telnet命令登录到该 端口上，接着==拔掉ernest-laptop的网线，并在Kongming20上中断服务器程序。==显然，此时ernest-laptop上运行的telnet客户端程序维持着一个半 打开连接。然后==接上ernest-laptop的网线，并从客户端程序往半打开连 接写入1字节的数据“a”。==同时，运行tcpdump程序抓取整个过程中 telnet客户端和nc服务器交换的TCP报文段。

截取的数据报如下：

```bash
1.IP 192.168.1.108.55100＞192.168.1.109.12345:Flags[S],seq 3093809365,length 0
2.IP 192.168.1.109.12345＞192.168.1.108.55100:Flags[S.],seq 1495337791,ack 3093809366,length 0
3.IP 192.168.1.108.55100＞192.168.1.109.12345:Flags[.],ack 1,length 0
#前三次正常握手
4.IP 192.168.1.108.55100＞192.168.1.109.12345:Flags[P.],seq 1:4,ack 1,length 3
5.IP 192.168.1.109.12345＞192.168.1.108.55100:Flags[R],seq 1495337792,length 0
#第4个TCP报文段由客户端发送给服务器，它携带了3字节的应用程序数据，这3字节依次是：字母“a”、回车符“\r”和换行符“\n”。不过因为服务器程序已经被中断，所以Kongming20对客户端发送的数据回应了一个复位报文段5。
```

## TCP交互数据流

TCP报文段所携带的应用程序数据按照长度 分为两种：交互数据和成块数据。

==交互数据仅包含很少的字节。使用 交互数据的应用程序（或协议）对实时性要求高，比如telnet、ssh等。==

### 观察交互数据流

考虑如下情况：在ernest-laptop上执行telnet命令登录到本机，然后 在shell命令提示符后执行ls命令

```bash
#不包括握手和挥手的IP数据报
1.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[P.],seq 1408334812:1408334813,ack 1415955507,win 613,length 1
#由客户端发送给服务器，它携带1个字节的应用程序数据，即字母“l”。
2.IP 127.0.0.1.23＞127.0.0.1.58130:Flags[P.],seq 1:2,ack 1,win 512,length 1
#服务器对TCP报文段1的确认，同时回显字母“l”
3.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[.],ack 2,win 613,length 0
#客户端对TCP报文段2的确认
4.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[P.],seq 1:2,ack 2,win 613,length 1
5.IP 127.0.0.1.23＞127.0.0.1.58130:Flags[P.],seq 2:3,ack 2,win 512,length 1
6.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[.],ack 3,win 613,length 0
#针对字母“s”的上述过程。
7.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[P.],seq 2:4,ack 3,win 613,length 2
#传送的2字节数据分别是：客户端键入的回车符和流结束符（EOF，本例中是0x00）。
8.IP 127.0.0.1.23＞127.0.0.1.58130:Flags[P.],seq 3:176,ack 4,win 512,length 173
#携带服务器返回的客户查询的目录的内容（ls命令的输出），包括该目录下文件的文件名及其显示控制参数。
9.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[.],ack 176,win 630,length 0
#客户端对TCP报文段8的确认。
10.IP 127.0.0.1.23＞127.0.0.1.58130:Flags[P.],seq 176:228,ack 4,win 512,length 52
#携带的也是服务器返回给客户端的数据，包括一个回车符、一个换行符、客户端登录用户的PS1环境变量（第一级命令提示符）。
11.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[.],ack 228,win 630,length 0
#客户端对TCP报文段10的确认。
```

在上述过程中，客户端针对服务器返回的数据所发送的确认报文段（TCP报文段6、9和11）都不携带任何应用程序数据（长度为0）， 而服务器每次发送的确认报文段（TCP报文段2、5、8和10）都包含它 需要发送的应用程序数据。

服务器的这种处理方式称为==延迟确认，即它不马上确认上次收到的数据，而是在一段延迟时间后查看本端是否有数据需要发送，如果有，则和确认信息一起发出。==

上例是在本地回路运行的结果，在局域网中也能得到基本相同的 结果，但在广域网就未必如此了。广域网上的交互数据流可能经受很 大的延迟，并且，携带交互数据的微小TCP报文段数量一般很多（一 个按键输入就导致一个TCP报文段），这些因素都可能导致拥塞发 生。解决该问题的一个简单有效的方法是使用Nagle算法。

==Nagle算法要求一个TCP连接的通信双方在任意时刻都最多只能发送一个未被确认的TCP报文段，在该TCP报文段的确认到达之前不能 发送其他TCP报文段。==另一方面，发送方在等待确认的同时收集本端 需要发送的微量数据，并在确认到来时以一个TCP报文段将它们全部 发出。这样就极大地减少了网络上的微小TCP报文段的数量。该算法 的另一个优点在于其自适应性：确认到达得越快，数据也就发送得越 快

## TCP成块数据流

成块数据的长度则通常为TCP报文段允许的最大数据长度。使用成块数据的应用程序（或协议）对传输效率要求高，==比如ftp。==

下面考虑用FTP协议传输一个大文件。在ernest-laptop上启动一个 vsftpd服务器程序（升级的、安全版的ftp服务器程序），并执行ftp命令登录该服务器上，然后在ftp命令提示符后输入get命令，从服务器下 载一个几百兆的大文件。同时用tcpdump抓取这一个过程中ftp客户端 和vsftpd服务器交换的TCP报文段。

```bash
$sudo tcpdump-nt-i eth0 port 20#vsftpd服务器程序使用端口号20
$ftp 127.0.0.1
Connected to 127.0.0.1.
220(vsFTPd 2.3.0)
Name(127.0.0.1:ernest):ernest（回车）#输入用户名并回车
331 Please specify the password.
Password:（回车）#输入密码并回车
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp＞get bigfile（回车）#获取大文件bigfile
```

```bash
1.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205783041:205799425,ack 1,win 513,length 16384
2.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205799425:205815809,ack 1,win 513,length 16384
3.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205815809:205832193,ack 1,win 513,length 16384
4.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[P.],seq 205832193:205848577,ack 1,win 513,length 16384
5.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205848577:205864961,ack 1,win 513,length 16384
6.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205864961:205881345,ack 1,win 513,length 16384
7.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205881345:205897729,ack 1,win 513,length 16384
8.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[P.],seq 205897729:205914113,ack 1,win 513,length 16384
9.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205914113:205930497,ack 1,win 513,length 16384
10.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205930497:205946881,ack 1,win 513,length 16384
11.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205946881:205963265,ack 1,win 513,length 16384
12.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[P.],seq 205963265:205979649,ack 1,win 513,length 16384
13.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205979649:205996033,ack 1,win 513,length 16384
14.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205996033:206012417,ack 1,win 513,length 16384
15.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 206012417:206028801,ack 1,win 513,length 16384
16.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[P.],seq 206028801:206045185,ack 1,win 513,length 16384
17.IP 127.0.0.1.39651＞127.0.0.1.20:Flags[.],ack 205815809,win 30084,length 0
#对报文段2的确认，由此可见，当传输大量大块数据的时候，发送方会连续发送多个TCP报文段，接收方可以一次确认所有这些报文段。
#TCP报文段17说明客户端还能接收30 084×64字节（本例中窗口扩大因子为6），即1 925 376字节的数据。
18.IP 127.0.0.1.39651＞127.0.0.1.20:Flags[.],ack 206045185,win 27317,length 0
#对报文段16的确认，即1 925 376字节的数据。而在TCP报文段18中，接收通告窗口大小为1 748 288字节，即客户端能接收的数据量变小了。这表明客户端的TCP接收缓冲区有更多的数据未被应用程序读取而停留在其中，这些数据都来自TCP报文段3～16中的一部分。

#注意，TCP协议中，每次都只会按序收到的数据中的 最高序号 给出确认
```

另外一个值得注意的地方是，==服务器每发送4个TCP报文段就传送 一个PSH标志（tcpdump输出标志P）给客户端==，以通知客户端的应用 程序尽快读取数据。不过这对服务器来说显然不是必需的，因为它知道客户端的TCP接收缓冲区中还有空闲空间（接收通告窗口大小不为 0）。

## TCP带外数据

有些传输层协议具有带外（Out Of Band，OOB）数据的概念，用 于迅速通告对方本端发生的重要事件。因此，带外数据比普通数据 （也称为带内数据）==有更高的优先级，它应该总是立即被发送，==而不 论发送缓冲区中是否有排队等待发送的普通数据。

实际应用中，==带外数据的使用很少见，==已知的仅有telnet、ftp等远 程非活跃程序。

UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过 TCP利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提 供了一种紧急方式。TCP的紧急方式利用传输普通数据的连接来传输紧 急数据。这种紧急数据的含义和带外数据类似，因此后文也将TCP紧急 数据称为带外数据。

## TCP超时重传

如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器。至于下次重传的超时 时间如何选择，以及最多执行多少次重传，就是TCP的重传策略。

### tcpdump模拟超时重传

在ernest-laptop上启动iperf服务器程序，然后从Kongming20上执行 telnet命令登录该服务器程序。接下来，从telnet客户端发送一些数据 （此处是“1234”）给服务器，然后断开服务器的网线并再次从客户端 发送一些数据给服务器（此处是“12”）。

```bash
$sudo tcpdump-n-i eth0 port 5001
$iperf-s#在ernest-laptop上执行
$telnet 192.168.1.108 5001#在Kongming20上执行
Trying 192.168.1.108...
Connected to 192.168.1.108.
Escape character is'^]'.
1234#发送完之后断开服务器网线
12
Connection closed by foreign host
```

输出：

```bash
1.18:44:57.580341 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[S],seq 2381272950,length 0
2.18:44:57.580477 IP 192.168.1.108.5001＞192.168.1.109.38234:Flags[S.],seq 466032301,ack 2381272951,length 0
3.18:44:57.580498 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[.],ack 1,length 0
#1-3为握手报文段
4.18:44:59.866019 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[P.],seq 1:7,ack 1,length 6
5.18:44:59.866165 IP 192.168.1.108.5001＞192.168.1.109.38234:Flags[.],ack 7,length 0
#发送1234
6.18:45:25.028933 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[P.],seq 7:11,ack 1,length 4
#发送12，但是此时服务器被断网
7.18:45:25.230034 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[P.],seq 7:11,ack 1,length 4
8.18:45:25.639407 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[P.],seq 7:11,ack 1,length 4
9.18:45:26.455942 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[P.],seq 7:11,ack 1,length 4
10.18:45:28.092425 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[P.],seq 7:11,ack 1,length 4
11.18:45:31.362473 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[P.],seq 7:11,ack 1,length 4
#7-11是在超时重传
#观察TCP报文段6～11被发送的时间间隔，它们分别为0.2s、0.4s、0.8s、1.6s和3.2s。
#由此可见，TCP一共执行5次重传，每次重传超时时间都增加一倍
12.18:45:33.100888 ARP,Request who-has 192.168.1.108 tell192.168.1.109,length 28
13.18:45:34.098156 ARP,Request who-has 192.168.1.108 tell192.168.1.109,length 28
14.18:45:35.100887 ARP,Request who-has 192.168.1.108 tell192.168.1.109,length 28
15.18:45:37.902034 ARP,Request who-has 192.168.1.108 tell192.168.1.109,length 28
16.18:45:38.903126 ARP,Request who-has 192.168.1.108 tell192.168.1.109,length 28
17.18:45:39.901421 ARP,Request who-has 192.168.1.108 tell192.168.1.109,length 28
18.18:45:44.440049 ARP,Request who-has 192.168.1.108 tell192.168.1.109,length 28
19.18:45:45.438840 ARP,Request who-has 192.168.1.108 tell192.168.1.109,length 28
20.18:45:46.439932 ARP,Request who-has 192.168.1.108 tell192.168.1.109,length 28
21.18:45:50.976710 ARP,Request who-has 192.168.1.108 tell192.168.1.109,length 28
22.18:45:51.974134 ARP,Request who-has 192.168.1.108 tell192.168.1.109,length 28
23.18:45:52.973939 ARP,Request who-has 192.168.1.108 tell192.168.1.109,length 28
#在5次重传均失败的情况下，底层的IP和ARP开始接管，直到telnet客户端放弃连接为止
```

## 拥塞控制

拥塞控制 的四个部分：慢启动（slow start）、拥塞避免（congestion avoidance）、快速重传（fast retransmit）和快速恢复（fast recovery）。

# 第四章 TCP/IP通信案例：访问Internet上的Web服务器

Web客户端和服务器之间使用HTTP协议通信。HTTP协议的内容相 当广泛，涵盖了网络应用层协议需要考虑的诸多方面。因此，学习 HTTP协议对应用层协议设计将大有裨益。

我们按照如下方法来部署通信实例：在==Kongming20上运行wget客户端程序，在ernest-laptop上运行squid代理服务器程序。==客户端通过代 理服务器的中转，获取Internet上的主机www.baidu.com的首页文档 index.html

![图4·1 通过代理服务器访问Internet上的Web服务器](C:\Users\Administrator\Desktop\笔记\llinux服务器\图4·1 通过代理服务器访问Internet上的Web服务器.png)

wget客户端程序和代理服务器之间，以及代理服务 器与Web服务器之间都是使用HTTP协议通信的。==HTTP协议是一种应用层协议，它默认使用的传输层协议是TCP协议。==我们将在后文中简单讨 论HTTP协议。

为了将ernest-laptop设置为Kongming20的HTTP代理服务器，我们 需要在Kongming20上设置环境变量http_proxy：

```bash
export http_proxy="ernest-laptop:3128" #在Kongming20上执行
#proxy就是代理服务器的意思
```

其中，3128是squid服务器默认使用的端口号（可以通过lsof命令查 看服务器程序监听的端口号，见第17章）。设置好环境变量之后， Kongming20访问任何Internet上的Web服务器时，其HTTP请求都将首先 发送至ernest-laptop的3128端口。

## 部署代理服务器

### HTTP代理服务器的工作原理

在HTTP通信链上，客户端和目标服务器之间通常存在某些==中转代理服务器，它们提供对目标资源的中转访问。==一个HTTP请求可能被多 个代理服务器转发，后面的服务器称为前面服务器的上游服务器。代 理服务器按照其使用方式和作用，分为正向代理服务器、反向代理服 务器和透明代理服务器。

正向代理要求客户端自己设置代理服务器的地址。==客户的每次请求都将直接发送到该代理服务器，并由代理服务器来请求目标资源。== 比如处于防火墙内的局域网机器要访问Internet，或者要访问一些被屏 蔽掉的国外网站，就需要使用正向代理服务器。

反向代理则被设置在服务器端，因而客户端无须进行任何设置。 ==反向代理是指用代理服务器来接收Internet上的连接请求，然后将请求 转发给内部网络上的服务器，并将从内部服务器上得到的结果返回给客户端。==这种情况下，代理服务器对外就表现为一个真实的服务器。 各大网站通常分区域设置了多个代理服务器，所以在不同的地方ping同一个域名可能得到不同的IP地址，因为这些IP地址实际上是代理服务器 的IP地址。

![图4·2 HTTP通信链上的代理服务器](C:\Users\Administrator\Desktop\笔记\llinux服务器\图4·2 HTTP通信链上的代理服务器.png)

透明代理只能设置在网关上。用户访问Internet的数据报必然都经 过网关，如果在网关上设置代理，则该代理对用户来说显然是透明 的。==透明代理可以看作正向代理的一种特殊情况。==

### 部署squid代理服务器

修改squid服务器的配置文件/etc/squid3/squid.conf，在其中加 入如下两行代码

```bash
acl localnet src 192.168.1.0/24
http_access allow localnet
#允许网络192.168.1.0上的所有机器通过该代理服务器来访问Web服务器
```

接下来在ernest-laptop上执行如下命令，以重启squid服务器：

```bash
$sudo service squid3 restart
*Restarting Squid HTTP Proxy 3.0 squid3[OK]
```

==service是一个脚本程序（/usr/sbin/service），它为/etc/init.d/目录下 的众多服务器程序（比如httpd、vsftpd、sshd和mysqld等）的启动 （start）、停止（stop）和重启（restart）等动作提供了一个统一的管理。==现在，Linux程序员已经越来越偏向于使用service脚本来管理服务 器程序了

### 使用tcpdump抓取传输数据包

首先应删除ernest-laptop的ARP高速缓存 中路由器对应的项，以便观察TCP/IP通信过程中ARP协议何时起作用。然后，使用tcpdump命令抓取整个通信过程中传输的数据包。

```bash
$sudo arp -d 192.168.1.1
$sudo tcpdump -s 2000 -i eth0 -ntX'(src 192.168.1.108)or(dst
192.168.1.108)or(arp)'
$wget --header="Connection:close"http://www.baidu.com/index.html
 --2012-07-03 00:51:12 --http://www.baidu.com/index.html
Resolving ernest-laptop...192.168.1.108
Connecting to ernest-laptop|192.168.1.108|:3128...connected.
Proxy request sent,awaiting response...200 OK
Length:8024(7.8K)[text/html]
Saving to:“index.html”
100%[=======================＞]8,024--.-K/s in 0.001s
2012-07-03 00:51:12(8.76 MB/s)-“index.html”saved[8024/8024]
#wget命令的输出显示，HTTP请求确实是先被送至代理服务器的3128端口，并且代理服务器正确地返回了文件index.html的内容。
```

该次操作的tcpdump输出如下：

```bash
#这些数据包不是一对客户端和服务器之间交换的内容，而是两对客户端和服务器（wget客户端和代理服务器，以及代理服务器和目标Web服务器）
1.IP 192.168.1.109.40988＞192.168.1.108.3128:Flags[S],seq 227192137,length 0
2.IP 192.168.1.108.3128＞192.168.1.109.40988:Flags[S.],seq 1084588508,ack 227192138,length 0
3.IP 192.168.1.109.40988＞192.168.1.108.3128:Flags[.],ack 1,length 0
4.IP 192.168.1.109.40988＞192.168.1.108.3128:Flags[P.],seq 1:137,ack 1,length 136
5.IP 192.168.1.108.3128＞192.168.1.109.40988:Flags[.],ack 137,length 0
#1-5，wget客户端（192.168.1.109）和代理服务器（192.168.1.108）之间的HTTP通信
6.ARP,Request who-has 192.168.1.1 tell 192.168.1.108,length 28
7.ARP,Reply 192.168.1.1 is-at 14:e6:e4:93:5b:78,length 46
#6-7代理服务器查询路由器MAC地址的ARP请求和应答
8.IP 192.168.1.108.46149＞219.239.26.42.53:59410+A? www.baidu.com.(31)
9.IP 219.239.26.42.53＞192.168.1.108.46149:59410 3/4/0 CNAME www.a.shifen.com.,A 119.75.218.77,A 119.75.217.56(162)
#8-9代理服务器访问DNS服务器以查询域名www.baidu.com对应的IP地址
10.IP 192.168.1.108.34538＞119.75.218.77.80:Flags[S],seq 1084002207,length 0
11.IP 119.75.218.77.80＞192.168.1.108.34538:Flags[S.],seq 4261071806,ack 1084002208,length 0
12.IP 192.168.1.108.34538＞119.75.218.77.80:Flags[.],ack 1,length 0
13.IP 192.168.1.108.34538＞119.75.218.77.80:Flags[P.],seq 1:226,ack 1,length 225
14.IP 119.75.218.77.80＞192.168.1.108.34538:Flags[.],ack 226,length 0
15.IP 119.75.218.77.80＞192.168.1.108.34538:Flags[P.],seq 1:380,ack 226,length 379
16.IP 192.168.1.108.34538＞119.75.218.77.80:Flags[.],ack 380,length 0
17.IP 119.75.218.77.80＞192.168.1.108.34538:Flags[.],seq 380:1820,ack 226,length 1440
18.IP 192.168.1.108.34538＞119.75.218.77.80:Flags[.],ack 1820,length 0
19.IP 119.75.218.77.80＞192.168.1.108.34538:Flags[.],seq 1820:3260,ack 226,length 1440
20.IP 192.168.1.108.34538＞119.75.218.77.80:Flags[.],ack 3260,length 0
21.IP 119.75.218.77.80＞192.168.1.108.34538:Flags[P.],seq 3260:4700,ack 226,length 1440
22.IP 192.168.1.108.34538＞119.75.218.77.80:Flags[.],ack 4700,length 0
#10-22，代理服务器和Web服务器（119.75.218.77）之间的HTTP通信
23.IP 192.168.1.108.3128＞192.168.1.109.40988:Flags[.],seq 1:1449,ack 137,length 1448
24.IP 192.168.1.108.3128＞192.168.1.109.40988:Flags[P.],seq 1449:2166,ack 137,length 717
25.IP 192.168.1.108.3128＞192.168.1.109.40988:Flags[.],seq 2166:3614,ack 137,length 1448
#23-25，wget客户端（192.168.1.109）和代理服务器（192.168.1.108）之间的HTTP通信
26.IP 119.75.218.77.80＞192.168.1.108.34538:Flags[.],seq 4700:6140,ack 226,length 1440
27.IP 192.168.1.108.34538＞119.75.218.77.80:Flags[.],ack 6140,length 0
28.IP 119.75.218.77.80＞192.168.1.108.34538:Flags[.],seq 6140:7580,ack 226,length 1440
29.IP 192.168.1.108.34538＞119.75.218.77.80:Flags[.],ack 7580,length 0
30.IP 119.75.218.77.80＞192.168.1.108.34538:Flags[FP.],seq 7580:8404,ack 226,length 824
31.IP 192.168.1.108.34538＞119.75.218.77.80:Flags[F.],seq 226,ack 8405,length 0
#26-31，代理服务器和Web服务器（119.75.218.77）之间的HTTP通信
32.IP 192.168.1.109.40988＞192.168.1.108.3128:Flags[.],ack 1449,length 0
33.IP 192.168.1.108.3128＞192.168.1.109.40988:Flags[.],seq 3614:6510,ack 137,length 2896
34.IP 192.168.1.109.40988＞192.168.1.108.3128:Flags[.],ack 2166,length 0
35.IP 192.168.1.108.3128＞192.168.1.109.40988:Flags[.],seq 6510:7958,ack 137,length 1448
36.IP 192.168.1.108.3128＞192.168.1.109.40988:Flags[FP.],seq 7958:8523,ack 137,length 565
37.IP 192.168.1.109.40988＞192.168.1.108.3128:Flags[.],ack 3614,length 0
38.IP 192.168.1.109.40988＞192.168.1.108.3128:Flags[.],ack 5062,length 0
39.IP 192.168.1.109.40988＞192.168.1.108.3128:Flags[.],ack 6510,length 0
40.IP 192.168.1.109.40988＞192.168.1.108.3128:Flags[.],ack 7958,length 0
#32-40，wget客户端（192.168.1.109）和代理服务器（192.168.1.108）之间的HTTP通信
41.IP 119.75.218.77.80＞192.168.1.108.34538:Flags[.],ack 227,length 0
#41.代理服务器和Web服务器（119.75.218.77）之间的HTTP通信
42.IP 192.168.1.109.40988＞192.168.1.108.3128:Flags[F.],seq 137,ack 8524,length 0
43.IP 192.168.1.108.3128＞192.168.1.109.40988:Flags[.],ack 138,length 0
#42-43，wget客户端（192.168.1.109）和代理服务器（192.168.1.108）之间的HTTP通信
```

## 访问DNS服务器

数据包8、9表示代理服务器ernest-laptop向DNS服务器 （219.239.26.42，首选DNS服务器的IP地址，见1.6.2节）查询域名 www.baidu.com对应的IP地址，并得到了回复。该回复包括一个主机别 名（www.a.shifen.com）和两个IP地址（119.75.218.77和 119.75.217.56）。

![图4-3 DNS查询](C:\Users\Administrator\Desktop\笔记\llinux服务器\图4-3 DNS查询.png)

squid程序通过读取/etc/resolv.conf文件获得DNS服务器的IP地址 （见1.6.2节），然后将控制权传递给内核中的UDP模块。UDP模块将 DNS查询报文封装成UDP数据报，同时把源端口号和目标端口号加入 UDP数据报头部，然后UDP模块调用IP服务。IP模块则将UDP数据报封 装成IP数据报，并把源端IP地址（192.168.1.108）和DNS服务器的IP地 址加入IP数据报头部。接下来，IP模块查询路由表以决定如何发送该IP 数据报。根据路由策略，目标IP地址（219.239.26.42）仅能匹配路由表 中的默认路由项，因此该IP数据报先被发送至路由器（IP地址为 192.168.1.1），然后通过路由器来转发。因为ernest-laptop的ARP缓存 中没有与路由器对应的缓存项（我们手动将其删除了），所以ernestlaptop需要发起一个ARP广播以查询路由器的IP地址，而这正是数据包6 描述的内容。路由器则通过ARP应答告诉ernest-laptop自己的MAC地址 是14:e6:e4:93:5b:78，如数据包7所示。最终，以太网驱动程序将IP数据 报封装成以太网帧发送给路由器。==此后，代理服务器再次发送数据到 Internet时将不再需要ARP查询，==因为ernest-laptop的ARP高速缓存中已 经记录了路由器的IP地址和MAC地址的映射关系。

==IP头部的源端IP地址和目的端IP地址在转发过程中是始终不变的（一种 例外是源路由选择）。但帧头部的源端物理地址和目的端物理地址在 转发过程中则是一直在变化的。==

## 本地名称查询

一般来说，通过域名来访问Internet上的某台主机时，需要使用 DNS服务来获取该主机的IP地址。==但如果我们通过主机名来访问本地 局域网上的机器，则可通过本地的静态文件来获得该机器的IP地址。==

Linux将目标主机名及其对应的IP地址存储在/etc/hosts配置文件 中。当需要查询某个主机名对应的IP地址时，程序将首先检查这个文 件。Kongming20上/etc/hosts文件的内容如下（笔者手动修改过）：

```bash
127.0.0.1 localhost #本地回路地址127.0.0.1的名称是localhost
192.168.1.109 Kongming20 
192.168.1.108 ernest-laptop #Kongming20和ernest-laptop的IP地址及对应的主机名。
```

wget命令输出“Resolving ernestlaptop...192.168.1.108”，即它成功地解析了主机名ernest-laptop对应的 IP地址，原因如下：当wget访问某个Web服务器时，==它先读取环境变量http_proxy。如果该环境变量被设置，并且我们没有阻止wget使用代 理服务，则wget将通过http_proxy指定的代理服务器来访问Web服务==

如果程序在/etc/hosts文件中未找到目标机器名对应的IP地址，它 将求助于DNS服务。

## HTTP通信

![图4-4 wget客户端和squid服务器之间的TCP通信](C:\Users\Administrator\Desktop\笔记\llinux服务器\图4-4 wget客户端和squid服务器之间的TCP通信.png)

TCP连接从建立到关闭的过程中，==客户端仅给服务器发送了一个HTTP请求（即TCP报文段4）==，该请求的长度为136字节（见代码清单4-2中TCP报文段4的length值）。

TCP报文段（23、24、25、33、35和36）给客户端返回了总长度为8522 字节（这可以从对方的最后一个确认报文段42的确认值计算得到，考 虑同步报文段和结束报文段各占用一个序号）的HTTP应答。客户端使用了7个TCP报文段（32、34、37、38、39、40和42）来确认这8522字 节的HTTP应答数据。

分析一下这136字节的HTTP请求和8522字节的HTTP 应答的部分主要内容==(代码中使用tcpdump -X查看)==

```bash
#HTTP请求部分内容如下
GET http://www.baidu.com/index.html HTTP/1.0 #请求行。其中“GET”是请求方法，表示客户端以只读的方式来申请资源。
User-Agent:Wget/1.12(linux-gnu) #表示客户端使用的程序是wget。
Host:www.baidu.com #表示目标主机名是www.baidu.com。
Connection:close #是我们执行wget命令时传入的（见代码清单4-1），用以告诉服务器处理完这个HTTP请求之后就关闭连接
#第2～4行都是HTTP请求的头部字段。一个HTTP请求可以包含多个头部字段。一个头部字段用一行表示，包含字段名称、冒号、空格和字段的值。HTTP请求中的头部字段可按任意顺序排列。
```

### HTTP请求方法

![表4-1 HTTP请求方法](C:\Users\Administrator\Desktop\笔记\llinux服务器\表4-1 HTTP请求方法.png)

这些方法中，HEAD、GET、OPTIONS和TRACE被视为安全的方 法，因为它们只是从服务器获得资源或信息，而不对服务器进行任何 修改。而POST、PUT、DELETE和PATCH则影响服务器上的资源。 另一方面，GET、HEAD、OPTIONS、TRACE、PUT和DELETE 等请求方法被认为是等幂的（idempotent），即多次连续的、重复的请 求和只发送一次该请求具有完全相同的效果。而POST方法则不同，连 续多次发送同样一个请求可能进一步影响服务器上的资源。

==同一个客户的多个连续的HTTP请求不能共用同一个TCP连接，这称为短连接。 长连接与之相反，是指多个请求可以使用同一个TCP连接。==长连接在编 程上稍微复杂一些，但性能上却有很大提高：它极大地减少了网络上 为建立TCP连接导致的负荷，同时对每次请求而言缩减了处理时间。

## HTTP应答

```bash
HTTP/1.0 200 OK #状态行。“HTTP/1.0”是服务器使用的HTTP协议的版本号。通常，服务器需要使用和客户端相同的HTTP协议版本。“200 OK”是状态码和状态信息。
#第2～7行是HTTP应答的头部字段。其表示方法与HTTP请求中的头部字段相同。
Server:BWS/1.0 #目标Web服务器程序的名字是BWS
Content-Length:8024 #表示目标文档的长度为8024字节。这个值和wget输出的文档长度一致。
Content-Type:text/html;charset=gbk #表示目标文档的MIME类型。其中“text”是主文档类型，“html”是子文档类型。“text/html”表示目标文档index.html是text类型中的html文档。“charset”是text文档类型的一个参数，用于指定文档的字符编码。
SetCookie:BAIDUID=A5B6C72D68CF639CE8896FD79A03FBD8:FG=1;expires=Wed,04-Jul-42 00:10:47 GMT;path=/;domain=.baidu.com #表示服务器传送一个Cookie给客户端。其中，“BAIDUID”指定Cookie的名字，“expires”指定Cookie的生存时间，“domain”和“path”指定该Cookie生效的域名和路径。
Via:1.0 localhost(squid/3.0 STABLE18)#表示HTTP应答在返回过程中经历过的所有代理服务器的地址和名称
```

![表4-2 HTTP状态码和状态信息及其含义](C:\Users\Administrator\Desktop\笔记\llinux服务器\表4-2 HTTP状态码和状态信息及其含义.png)

Cookie 是服务器发送给客户端的特殊信息（通过HTTP应答的头部字段“SetCookie”），客户端每次向服务器发送请求的时候都需要带上这些信息 （通过HTTP请求的头部字段“Cookie”）。这样服务器就可以区分不同 的客户了。基于浏览器的自动登录就是用Cookie实现的。

# 第五章 linux网络编程基础API

从如下3个方面讨论Linux网络API：

❑socket地址API。socket最开始的含义是一个IP地址和端口对（ip，port）。它唯一地表示了使用TCP通信的一端。本书称其为socket 地址。 
❑socket基础API。socket的主要API都定义在sys/socket.h头文件 中，包括创建socket、命名socket、监听socket、接受连接、发起连接、 读写数据、获取地址信息、检测带外标记，以及读取和设置socket选 项。 
❑网络信息API。Linux提供了一套网络信息API，以实现主机名和IP地址之间的转换，以及服务名称和端口号之间的转换。这些API都定 义在netdb.h头文件中，我们将讨论其中几个主要的函数。

## SOCKET地址API

### 主机字节序和网络字节序

那么这4字节在内存中排列的顺序将影响它 被累加器装载成的整数的值。这就是字节序问题。字节序分为大端字节序（big endian）和小端字节序（little endian）。

大端字节序是指一 个整数的高位字节（23～31 bit）存储在内存的低地址处，低位字节（0 ～7 bit）存储在内存的高地址处。==（逆序）==

小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。==（顺序）==

现代PC大多采用小端字节序，因此==小端字节序又被称为主机字节序。==

当格式化的数据（比如32 bit整型数和16 bit短整型数）在两台使用不同字节序的主机之间直接传递时，接收端必然错误地解释之。解决 问题的方法是：==发送端总是把要发送的数据转化成大端字节序数据后再发送==，而接收端知道对方传送过来的数据总是采用大端字节序，所 以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转 换（小端机转换，大端机不转换）。因此大端字节序也称为网络字节序，它给所有接收数据的主机提供了一个正确解释收到的格式化数据 的保证。

### Linux提供了如下4个函数来完成主机字节序和网络字节序之间的转换：

```C++
#include＜netinet/in.h＞
unsigned long int htonl(unsigned long int hostlong); //htonl表示“host to network long”
unsigned short int htons(unsigned short int hostshort);//htons表示“host to network short”
unsigned long int ntohl(unsigned long int netlong);
unsigned short int ntohs(unsigned short int netshort);
//这4个函数中，长整型函数通常用来转换IP地址，短整型函数用来转换端口号
```

### 通用socket地址

socket网络编程接口中表示socket地址的是结构体sockaddr，其定义

```C++
#include＜bits/socket.h＞
struct sockaddr
{
sa_family_t sa_family; //就是用来表示地址类型的一个预定义变量
char sa_data[14];
}
```

sa_family成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称domain， 见后文）和对应的地址族如表5-1所示。

![表5-1 协议族和地址族的关系](C:\Users\Administrator\Desktop\笔记\llinux服务器\表5-1 协议族和地址族的关系.png)

宏PF _* 和 AF _*都定义在bits/socket.h头文件中，且后者与前者有完全相同的值，所以==二者通常混用==。

sa_data成员用于存放socket地址值。但是，==不同的协议族的地址值具有不同的含义和长度==

![表5-2 协议族及其地址值](C:\Users\Administrator\Desktop\笔记\llinux服务器\表5-2 协议族及其地址值.png)

14字节的sa_data根本无法完全容纳多数协议族的地址值。因此，Linux定义了下面这个新的通用socket地址结构体：

```C++
#include＜bits/socket.h＞
struct sockaddr_storage
{
sa_family_t sa_family;
unsigned long int __ss_align;
char __ss_padding[128-sizeof(__ss_align)];
}
```

### 专用socket地址

上面这两个通用socket地址结构体显然很不好用，比如==设置与获取IP地址和端口号就需要执行烦琐的位操作。==所以Linux为各个协议族提 供了专门的socket地址结构体

```C++
//UNIX本地域协议族使用如下专用socket地址结构体：
#include＜sys/un.h＞
struct sockaddr_un
{
sa_family_t sin_family;/*地址族：AF_UNIX*/
char sun_path[108];/*文件路径名*/
};
```

```C++
//TCP/IP协议族有sockaddr_in和sockaddr_in6两个专用socket地址结构体，它们分别用于IPv4和IPv6：
struct sockaddr_in
{
sa_family_t sin_family;/*地址族：AF_INET*/
u_int16_t sin_port;/*端口号，要用网络字节序表示*/
struct in_addr sin_addr;/*IPv4地址结构体，见下面*/
};
struct in_addr
{
u_int32_t s_addr;/*IPv4地址，要用网络字节序表示*/
};
struct sockaddr_in6
{
sa_family_t sin6_family;/*地址族：AF_INET6*/
u_int16_t sin6_port;/*端口号，要用网络字节序表示*/
u_int32_t sin6_flowinfo;/*流信息，应设置为0*/
struct in6_addr sin6_addr;/*IPv6地址结构体，见下面*/
u_int32_t sin6_scope_id;/*scope ID，尚处于实验阶段*/
};
struct in6_addr
{
unsigned char sa_addr[16];/*IPv6地址，要用网络字节序表示*/
};
```

![socket地址类型](C:\Users\Administrator\Desktop\笔记\llinux服务器\socket地址类型.png)

==所有专用socket地址（以及sockaddr_storage）类型的变量在实际使 用时都需要转化为通用socket地址类型sockaddr（强制转换即可）==，因 为所有socket编程接口使用的地址参数的类型都是sockaddr。

### IP地址转换函数

通常，人们习惯用可读性好的字符串来表示IP地址，比如用点分 十进制字符串表示IPv4地址，以及用十六进制字符串表示IPv6地址。

但 编程中我们需要先把它们转化为整数（二进制数）方能使用。

而记录日志时则相反，我们要把整数表示的IP地址转化为可读的字符串。

下面3个函数可用于用点分十进制字符串表示的IPv4地址和用网络字节序整数表示的IPv4地址之间的转换：

```C++
#include＜arpa/inet.h＞
in_addr_t inet_addr(const char*strptr); 
//用点分十进制字符串表示的IPv4地址转化为用网络字节序整数表示的IPv4地址。它失败时返回INADDR_NONE
int inet_aton(const char*cp,struct in_addr*inp);
//inet_aton函数完成和inet_addr同样的功能，但是将转化结果存储于参数inp指向的地址结构中。它成功时返回1，失败则返回0
char * inet_ntoa(struct in_addr in);
//将用网络字节序整数表示的IPv4地址转化为用点分十进制字符串表示的IPv4地址。但需要注意的是，该函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存，因此inet_ntoa是不可重入的。
```

### 不可重入的inet_ntoa函数

```C++
char*szValue1=inet_ntoa(“1.2.3.4”);
char*szValue2=inet_ntoa(“10.194.71.60”);
printf(“address 1:%s\n”,szValue1);
printf(“address 2:%s\n”,szValue2);
```

输出如下

```
address1:10.194.71.60
address2:10.194.71.60
```

下面这对更新的函数也能完成和前面3个函数同样的功能，并且它 们同时适用于IPv4地址和IPv6地址：

```C++
#include＜arpa/inet.h＞
int inet_pton(int af,const char*src,void*dst);
//将用字符串表示的IP地址src（用点分十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址）转换成用网络字节序整数表示的IP地址，并把转换结果存储于dst指向的内存中。其中，af参数指定地址族，可以是AF_INET或者AF_INET6。inet_pton成功时返回1，失败则返回0并设置errno
const char*inet_ntop(int af,const void*src,char*dst,socklen_t cnt)
//inet_ntop函数进行相反的转换，前三个参数的含义与inet_pton的参数相同，最后一个参数cnt指定目标存储单元的大小。下面的两个宏能帮助我们指定这个大小（分别用于IPv4和IPv6)
//inet_ntop成功时返回目标存储单元的地址，失败则返回NULL并设置errno。
    
#include＜netinet/in.h＞
#define INET_ADDRSTRLEN 16
#define INET6_ADDRSTRLEN 46
```

## 创建socket及其他socket初始化操作

UNIX/Linux的一个哲学是：所有东西都是文件。socket也不例 外，它就是可读、可写、可控制、可关闭的文件描述符。

socket系统调用可创建一个socket：

```C++
#include＜sys/types.h＞
#include＜sys/socket.h＞
int socket(int domain,int type,int protocol);
//domain参数告诉系统使用哪个底层协议族。对TCP/IP协议族而言，该参数应该设置为PF_INET（Protocol Family of Internet，用于IPv4）或PF_INET6（用于IPv6）；对于UNIX本地域协议族而言，该参数应该设置为PF_UNIX。

//type参数指定服务类型。服务类型主要有SOCK_STREAM服务（流服务）和SOCK_UGRAM（数据报）服务。对TCP/IP协议族而言，其值取SOCK_STREAM表示传输层使用TCP协议，取SOCK_DGRAM表示传输层使用UDP协议。值得指出的是，自Linux内核版本2.6.17起，type参数可以接受上述服务类型与下面两个重要的标志相与的值：SOCK_NONBLOCK和SOCK_CLOEXEC。它们分别表示将新创建的socket设为非阻塞的，以及用fork调用创建子进程时在子进程中关闭该socket。在内核版本2.6.17之前的Linux中，文件描述符的这两个属性都需要使用额外的系统调用（比如fcntl）来设置

//protocol参数是在前两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常都是唯一的（前两个参数已经完全决定了它的值）。几乎在所有情况下，我们都应该把它设置为0，表示使用默认协议。

//socket系统调用成功时返回一个socket文件描述符，失败则返回-1并设置errno
```

### 命名socket

创建socket时，我们给它指定了地址族，但是并未指定使用该地 址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给 socket命名。

==在服务器程序中，我们通常要命名socket，==因为只有命名 后客户端才能知道该如何连接它。==客户端则通常不需要命名socket，== 而是采用匿名方式，即使用操作系统自动分配的socket地。

```C++
#include＜sys/types.h＞
#include＜sys/socket.h＞
int bind(int sockfd,const struct sockaddr*my_addr,socklen_t addrlen);
//bind将my_addr所指的socket地址分配给未命名的sockfd文件描述符，addrlen参数指出该socket地址的长度。
```

​	成功时返回0，失败则返回-1并设置errno。其中两种常见的 errno是EACCES和EADDRINUSE，它们的含义分别是：

❑EACCES，被绑定的地址是受保护的地址，仅超级用户能够访问。比如普通用户将socket绑定到知名服务端口（端口号为0～1023） 上时，bind将返回EACCES错误

❑EADDRINUSE，被绑定的地址正在使用中。比如将socket绑定 到一个处于TIME_WAIT状态的socket地址

### 监听socket

socket被命名之后，还不能马上接受客户连接，我们需要使用如 下系统调用来创建一个监听队列以==存放待处理的客户连接：==

```C++
#include＜sys/socket.h＞
int listen(int sockfd,int backlog);
//sockfd参数指定被监听的socket。backlog参数提示内核监听队列的最大长度。
//监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息。
```

在不同的系统上，运行结果会有些差别，不 过监听队列中完整连接的上限通常比backlog值略大。

### 接受连接

下面的系统调用从listen监听队列中接受一个连接：

```C++
#include＜sys/types.h＞
#include＜sys/socket.h＞
int accept(int sockfd,struct sockaddr*addr,socklen_t*addrlen);
//sockfd参数是执行过listen系统调用的监听socket[1]。
//addr参数用来获取被接受连接的远端socket地址，该socket地址的长度由addrlen参数指出。
```

accept成功时返回一个新的连接socket，该socket唯一地标识了被接受的这个连接，服务器可通过读写该socket来与被接受连接对应的客户端通信。accept失败时返回-1并设置errno。

现在考虑如下情况：如果监听队列中处于ESTABLISHED状态的 连接对应的客户端出现网络异常（比如掉线），或者提前退出，那么 服务器对这个连接执行的accept调用是否成功？

==accept调用对于客户端网络断开毫不知情。accept只是从监听队列中取出连接，而不论连接处于何种状态（如上面的ESTABLISHED状态和CLOSE_WAIT状态），更不关心任何网络状况的变化。==

### 发起连接

如果说服务器通过listen调用来被动接受连接，那么客户端需要通 过如下系统调用来主动与服务器建立连接

```C++
#include＜sys/types.h＞
#include＜sys/socket.h＞
int connect(int sockfd,const struct sockaddr*serv_addr,socklen_t addrlen);
//sockfd参数由socket系统调用返回一个socket。
//serv_addr参数是服务器监听的socket地址
//addrlen参数则指定这个地址的长度
```

connect成功时返回0。一旦成功建立连接，sockfd就唯一地标识了 这个连接，客户端就可以通过读写sockfd来与服务器通信。

connect失败则返回-1并设置errno。其中两种常见的errno是ECONNREFUSED和 ETIMEDOUT，它们的含义如下：

❑ECONNREFUSED，目标端口不存在，连接被拒绝。

❑ETIMEDOUT，连接超时。

### 关闭连接

关闭一个连接实际上就是关闭该连接对应的socket，这可以通过如 下关闭普通文件描述符的系统调用来完成：

```C++
#include＜unistd.h＞
int close(int fd);
//fd参数是待关闭的socket
```

==不过，close系统调用并非总是立即关闭 一个连接，而是将fd的引用计数减1。==只有当fd的引用计数为0时，才真 正关闭连接。多进程程序中，一次fork系统调用默认将使父进程中打开 的socket的引用计数加1，因此我们必须在父进程和子进程中都对该 socket执行close调用才能将连接关闭。

如果==无论如何都要立即终止连接==（而不是将socket的引用计数减 1），可以使用如下的shutdown系统调用

```C++
#include＜sys/socket.h＞
int shutdown(int sockfd,int howto);
//howto参数决定了shutdown的行为
```

![表5-3 howto参数的可选值](C:\Users\Administrator\Desktop\笔记\llinux服务器\表5-3 howto参数的可选值.png)

## 数据读写

### TCP数据读写

对文件的读写操作read和write同样适用于socket。其中用于TCP流数据读写的系统调用是：

```C++
#include＜sys/types.h＞
#include＜sys/socket.h＞
ssize_t recv(int sockfd,void*buf,size_t len,int flags);
//recv读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小，flags参数的含义见后文，通常设置为0即可。
//recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们可能要多次调用recv，才能读取到完整的数据。
//recv可能返回0，这意味着通信对方已经关闭连接了。recv出错时返回-1并设置errno。
ssize_t send(int sockfd,const void*buf,size_t len,int flags);
//send往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。
//send成功时返回实际写入的数据的长度，失败则返回-1并设置errno。
```

![表5-4 flags参数的可选值](C:\Users\Administrator\Desktop\笔记\llinux服务器\表5-4 flags参数的可选值.png)

MSG_OOB选项给应用程序提 供了发送和接收带外数据的方法，示例如下：

### 发送带外数据

```C++
#include＜sys/socket.h＞
#include＜netinet/in.h＞
#include＜arpa/inet.h＞
#include＜assert.h＞
#include＜stdio.h＞
#include＜unistd.h＞
#include＜string.h＞
#include＜stdlib.h＞
int main(int argc,char*argv[])
{
    if(argc＜=2) //输入的参数数目不对时返回错误
    {
        printf("usage:%s ip_address port_number\n",basename(argv[0]));
        return 1;
    }
    const char*ip=argv[1];
    int port=atoi(argv[2]);
    
    struct sockaddr_in server_address;
    bzero(＆server_address,sizeof(server_address));
    server_address.sin_family=AF_INET;
    inet_pton(AF_INET,ip,＆server_address.sin_addr);
    server_address.sin_port=htons(port);
    
    int sockfd=socket(PF_INET,SOCK_STREAM,0);
    assert(sockfd＞=0);
    if(connect(sockfd,(struct sockaddr*)＆server_address,sizeof(server_address))＜0)
    {
    	printf("connection failed\n");
    }
    else
    {
        const char*oob_data="abc";
        const char*normal_data="123";
        send(sockfd,normal_data,strlen(normal_data),0);
        send(sockfd,oob_data,strlen(oob_data),MSG_OOB);//flag设置为带外数据
        send(sockfd,normal_data,strlen(normal_data),0);
    }
    close(sockfd);
    return 0;
}
```

### 接受带外数据

```C++
#include＜sys/socket.h＞
#include＜netinet/in.h＞
#include＜arpa/inet.h＞
#include＜assert.h＞
#include＜stdio.h＞
#include＜unistd.h＞
#include＜stdlib.h＞
#include＜errno.h＞
#include＜string.h＞
#define BUF_SIZE 1024
int main(int argc,char*argv[])
{
    if(argc＜=2)
    {
        printf("usage:%s ip_address port_number\n",basename(argv[0]));
        return 1;
    }
    const char*ip=argv[1];
    int port=atoi(argv[2]);
    
    struct sockaddr_in address;
    bzero(＆address,sizeof(address));
    address.sin_family=AF_INET;
    inet_pton(AF_INET,ip,＆address.sin_addr);
    address.sin_port=htons(port);
    
    int sock=socket(PF_INET,SOCK_STREAM,0);
    assert(sock＞=0);
    int ret=bind(sock,(struct sockaddr*)＆address,sizeof(address));
    assert(ret!=-1);
    ret=listen(sock,5);
    assert(ret!=-1);
    
    struct sockaddr_in client;
    socklen_t client_addrlength=sizeof(client);
    int connfd=accept(sock,(struct sockaddr*)＆client,＆client_addrlength);
    if(connfd＜0)
    {
    	printf("errno is:%d\n",errno);
    }
    else
    {
        char buffer[BUF_SIZE];
        memset(buffer,'\0',BUF_SIZE);
        ret=recv(connfd,buffer,BUF_SIZE-1,0);
        printf("got%d bytes of normal data'%s'\n",ret,buffer);
        memset(buffer,'\0',BUF_SIZE);
        ret=recv(connfd,buffer,BUF_SIZE-1,MSG_OOB);
        printf("got%d bytes of oob data'%s'\n",ret,buffer);
        memset(buffer,'\0',BUF_SIZE);
        ret=recv(connfd,buffer,BUF_SIZE-1,0);
        printf("got%d bytes of normal data'%s'\n",ret,buffer);
        close(connfd);
    }
    close(sock);
    return 0;
}
```

接着在客户机和服务器中操作如下：

```bash
$./testoobrecv 192.168.1.109 54321#在Kongming20上执行服务器程序，监听
54321端口
$./testoobsend 192.168.1.109 54321#在ernest-laptop上执行客户端程序
$sudo tcpdump -ntx -i eth0 port 54321
```

最后程序输出结果如下：

```bash
got 5 bytes of normal data'123ab'
got 1 bytes of oob data'c'
got 3 bytes of normal data'123'
#由此可见，客户端发送给服务器的3字节的带外数据“abc”中，仅有最后一个字符“c”被服务器当成真正的带外数据接收
#并且，服务器对正常数据的接收将被带外数据截断，即前一部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全部读出的。
```

tcpdump的带外输出结果如下：

```bash
IP 192.168.1.108.60460＞192.168.1.109.54321:Flags[P.U],seq 4:7,ack 1,win 92,urg 3,options[nop,nop,TS val 102794322 ecr 154703423],length 3
```

这里我们第一次看到tcpdump==输出标志U，这表示该TCP报文段的 头部被设置了紧急标志。==“urg 3”是紧急偏移值，它指出带外数据在字 节流中的位置的下一字节位置是7（3+4，其中4是该TCP报文段的序号 值相对初始序号值的偏移）。因此，带外数据是字节流中的第6字节， 即字符“c”。

值得一提的是，==flags参数只对send和recv的当前调用生效，==而后面 我们将看到如何通过setsockopt系统调用永久性地修改socket的某些属 性。

### UDP数据读写

socket编程接口中用于UDP数据报读写的系统调用是：

```C++
#include＜sys/types.h＞
#include＜sys/socket.h＞
ssize_t recvfrom(int sockfd,void*buf,size_t len,int flags,struct sockaddr*src_addr,socklen_t*addrlen);
//recvfrom读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。
//因为UDP通信没有连接的概念，所以我们每次读取数据都需要获取发送端的socket地址，即参数src_addr所指的内容，addrlen参数则指定该地址的长度。
ssize_t sendto(int sockfd,const void*buf,size_t len,int flags,const struct sockaddr*dest_addr,socklen_t addrlen);
//sendto往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。
//dest_addr参数指定接收端的socket地址，addrlen参数则指定该地址的长度。
```

这两个系统调用的flags参数以及返回值的含义均与send/recv系统调 用的flags参数及返回值相同。

值得一提的是，==recvfrom/sendto系统调用也可以用于面向连接 （STREAM）的socket的数据读写，只需要把最后两个参数都设置为 NULL以忽略发送端/接收端的socket地址（因为我们已经和对方建立了连接，所以已经知道其socket地址了）。==

### 通用数据读取函数

socket编程接口还提供了一对通用的数据读写系统调用。它们不仅 能用于TCP流数据，也能用于UDP数据报：

```C++
#include＜sys/socket.h＞
ssize_t recvmsg(int sockfd,struct msghdr*msg,int flags);
ssize_t sendmsg(int sockfd,struct msghdr*msg,int flags);
//sockfd参数指定被操作的目标socket。msg参数是msghdr结构体类型的指针，msghdr结构体的定义如下：
struct msghdr
{
    void*msg_name;/*socket地址*/
    //msg_name成员指向一个socket地址结构变量。它指定通信对方的socket地址。对于面向连接的TCP协议，该成员没有意义，必须被设置为NULL。
    socklen_t msg_namelen;/*socket地址的长度*/
    struct iovec*msg_iov;/*分散的内存块，见后文*/
    int msg_iovlen;/*分散内存块的数量*/
    void*msg_control;/*指向辅助数据的起始位置*/
    socklen_t msg_controllen;/*辅助数据的大小*/
    int msg_flags;/*复制函数中的flags参数，并在调用过程中更新*/
};

//msg_iov成员是iovec结构体类型的指针，iovec结构体的定义如下：
struct iovec
{
    void*iov_base;/*内存起始地址*/
    size_t iov_len;/*这块内存的长度*/
};
//iovec结构体封装了一块内存的起始位置和长度。msg_iovlen指定这样的iovec结构对象有多少个。
```

对于recvmsg而言，数 据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长 度则由msg_iov指向的数组指定，这称为==分散读（scatter read）；==

对于 sendmsg而言，msg_iovlen块分散内存中的数据将被一并发送，这称为 ==集中写（gather write）==

## 带外标记

内核通知应用程序带外数据到达的两种常见方式是：==I/O复用产生的异常事件和SIGURG信号。==但是，即使应用程序得到了有带外数据需要接收的通知，还需要知道带外数据在数据流中的具体位置，才能准确接收带外数据。

```C++
#include＜sys/socket.h＞
int sockatmark(int sockfd);
//sockatmark判断sockfd是否处于带外标记，即下一个被读取到的数据是否是带外数据。
//如果是，sockatmark返回1，此时我们就可以利用带MSG_OOB标志的recv调用来接收带外数据。如果不是，则sockatmark返回0。
```

## 地址信息函数

在某些情况下，我们想知道一个连接socket的本端socket地址，以 及远端的socket地址。

```C++
#include＜sys/socket.h＞
int getsockname(int sockfd,struct sockaddr*address,socklen_t*address_len);
//getsockname获取sockfd对应的本端socket地址，并将其存储于address参数指定的内存中
//该socket地址的长度则存储于address_len参数指向的变量中。
//如果实际socket地址的长度大于address所指内存区的大小，那么该socket地址将被截断。
//getsockname成功时返回0，失败返回-1并设置errno。
int getpeername(int sockfd,struct sockaddr*address,socklen_t*address_len);
//getpeername获取sockfd对应的远端socket地址，其参数及返回值的含义与getsockname的参数及返回值相同
```

## socket选项

下面两个系统调用则是专门用来读取和设置socket文件描述符属性的方法：

```C++
#include＜sys/socket.h＞
int getsockopt(int sockfd,int level,int option_name,void*option_value,socklen_t *restrict option_len);
int setsockopt(int sockfd,int level,int option_name,const void*option_value,socklen_t option_len);
//sockfd参数指定被操作的目标socket。
//level参数指定要操作哪个协议的选项（即属性），比如IPv4、IPv6、TCP等。
//option_name参数则指选项的名字。
```

![表5-5 socket选项](C:\Users\Administrator\Desktop\笔记\llinux服务器\表5-5 socket选项.png)

值得指出的是，对服务器而言，==有部分socket选项只能在调用listen系统调用前针对监听socket[1]设置才有效。==这是因为连接socket只能由 accept调用返回，而accept从listen监听队列中接受的连接至少已经完成 了TCP三次握手的前两个步骤（因为listen监听队列中的连接至少已进 入SYN_RCVD状态，参见图3-8和代码清单5-4），这说明服务器已经 往被接受连接上发送出了TCP同步报文段。

==但有的socket选项却应该在TCP同步报文段中设置==，比如TCP最大报文段选项（回忆3.2.2小节，该 选项只能由同步报文段来发送）。对这种情况，Linux给开发人员提供 的解决方案是：==对监听socket设置这些socket选项，那么accept返回的连接socket将自动继承这些选项。==

这些socket选项包括：SO_DEBUG、 SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、 SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、 SO_SNDLOWAT、TCP_MAXSEG和TCP_NODELAY。==而对客户端而言，这些socket选项则应该在调用connect函数之前设置，因为connect调用成功返回之后，TCP三次握手已完成。==

### SO_REUSEADDR选项

服务器程序可以通过设置socket选项SO_REUSEADDR来强制使用被处于 TIME_WAIT状态的连接占用的socket地址。

经过setsockopt的设置之后，即使sock处于TIME_WAIT状态，与之 绑定的socket地址也可以立即被重用。

此外，我们也可以通过修改内核 参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而 使得TCP连接根本就不进入TIME_WAIT状态，进而允许应用程序立即 重用本地的socket地址

### SO_RCVBUF和SO_SNDBUF选项

SO_RCVBUF和SO_SNDBUF选项分别表示TCP接收缓冲区和发送 缓冲区的大小。不过，当我们用setsockopt来设置TCP的接收缓冲区和 发送缓冲区的大小时，==系统都会将其值加倍，并且不得小于某个最小值。==

TCP接收缓冲区的最小值是256字节，而发送缓冲区的最小值是 2048字节（不过，==不同的系统可能有不同的默认最小值==）系统这样 做的目的，主要是确保一个TCP连接拥有足够的空闲缓冲区来处理拥塞 （比如快速重传算法就期望TCP接收缓冲区能至少容纳4个大小为 SMSS的TCP报文段）。

此外，我们可以直接修改内核参 数/proc/sys/net/ipv4/tcp_rmem和/proc/sys/net/ipv4/tcp_wmem来强制TCP 接收缓冲区和发送缓冲区的大小没有最小值限制。

==当我们设置TCP接收缓冲区的大小为50字节时（小于最小值时），系统将忽略我们的设置。==

### SO_LINGER选项

SO_LINGER选项用于控制close系统调用在关闭TCP连接时的行为。默认情况下，当我们使用close系统调用来关闭一个socket时，close 将立即返回，TCP模块负责把该socket对应的TCP发送缓冲区中残留的数据发送给对方

设置（获取）SO_LINGER选项的值时，我们需要给 setsockopt（getsockopt）系统调用传递一个linger类型的结构体，其定 义如下：

```C++
#include＜sys/socket.h＞
struct linger
{
    int l_onoff;/*开启（非0）还是关闭（0）该选项*/
    int l_linger;/*滞留时间*/
};
```

==根据linger结构体中两个成员变量的不同值，close系统调用可能产 生如下3种行为之一：==

①l_onoff等于0。此时SO_LINGER选项不起作用，close用默认行为 来关闭socket
②l_onoff不为0，l_linger大于0。此时close的行为取决于两个条件：一是被关闭的socket对应的TCP发送缓冲区中是否还有残留的数据；二是该socket是阻塞的，还是非阻塞的。对于阻塞的socket，close 将等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并 得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到 对方的确认，那么close系统调用将返回-1并设置errno为 EWOULDBLOCK。如果socket是非阻塞的，close将立即返回，此时我 们需要根据其返回值和errno来判断残留数据是否已经发送完毕。

## 网络信息API

socket地址的两个要素，即IP地址和端口号，都是用数值表示的。 这不便于记忆，也不便于扩展（比如从IPv4转移到IPv6）。

我们用服务名称来代替端口号。比如，下面两条telnet命令 具有完全相同的作用：

```bash
telnet 127.0.0.1 80
telnet localhost www
#telnet客户端程序是通过调用某些网络信息API来实现主机名到IP地址的转换，以及服务名称到端口号的转换的
```

### gethostbyname和gethostbyaddr

```C++
#include＜netdb.h＞
struct hostent*gethostbyname(const char*name);
//gethostbyname函数根据主机名称获取主机的完整信息，gethostbyname函数通常先在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访问DNS服务器。
struct hostent*gethostbyaddr(const void*addr,size_t len,int type);
//gethostbyaddr函数根据IP地址获取主机的完整信息。

//name参数指定目标主机的主机名
//addr参数指定目标主机的IP地
//len参数指定addr所指IP地址的长度
//type参数指定addr所指IP地址的类型，其合法取值包括AF_INET（用于IPv4地址）和AF_INET6（用于IPv6地址）。
```

这两个函数返回的都是hostent结构体类型的指针，hostent结构体的 定义如下

```C++
#include＜netdb.h＞
struct hostent
{
    char*h_name;/*主机名*/
    char**h_aliases;/*主机别名列表，可能有多个*/
    int h_addrtype;/*地址类型（地址族）*/
    int h_length;/*地址长度*/
    char**h_addr_list/*按网络字节序列出的主机IP地址列表*/
};
```

### getservbyname和getservbyport

getservbyname函数根据名称获取某个服务的完整信息， getservbyport函数根据端口号获取某个服务的完整信息。它们实际上都是通过读取/etc/services文件来获取服务的信息的。

```C++
#include＜netdb.h＞
struct servent*getservbyname(const char*name,const char*proto);
struct servent*getservbyport(int port,const char*proto);
//name参数指定目标服务的名字，port参数指定目标服务对应的端口号。
//proto参数指定服务类型，给它传递“tcp”表示获取流服务，给它传递“udp”表示获取数据报服务，给它传递NULL则表示获取所有类型的服务

//这两个函数返回的都是servent结构体类型的指针，结构体servent的定义如下：
struct servent
{
    char*s_name;/*服务名称*/
    char**s_aliases;/*服务的别名列表，可能有多个*/
    int s_port;/*端口号*/
    char*s_proto;/*服务类型,通常是tcp或者udp*/
};
```

需要指出的是，==上面讨论的4个函数都是不可重入的，即非线程安全的。==不过netdb.h头文件给出了它们的可重入版本。正如Linux下所有 其他函数的可重入版本的命名规则那样，这些函数的函数名是在原函 数名尾部加上_r（re-entrant）。

### getaddrinfo

getaddrinfo函数既能通过主机名获得IP地址（内部使用的是 gethostbyname函数），也能通过服务名获得端口号（内部使用的是 getservbyname函数）。

它是否可重入取决于其内部调用的 gethostbyname和getservbyname函数是否是它们的可重入版本。

```C++
#include＜netdb.h＞
int getaddrinfo(const char*hostname,const char*service,const struct addrinfo*hints,struct addrinfo**result)
//hostname参数可以接收主机名，也可以接收字符串表示的IP地址 （IPv4采用点分十进制字符串，IPv6则采用十六进制字符串）。
//同样， service参数可以接收服务名，也可以接收字符串表示的十进制端口号。 
//hints参数是应用程序给getaddrinfo的一个提示，以对getaddrinfo的输出 进行更精确的控制。
//hints参数可以被设置为NULL，表示允许getaddrinfo反馈任何可用的结果。result参数指向一个链表，该链表用于存储getaddrinfo反馈的结果。
    
//getaddrinfo反馈的每一条结果都是addrinfo结构体类型的对象，结构体addrinfo的定义如下：
struct addrinfo
{
    int ai_flags;/*见后文*/
    //ai_flags成员可以取表5-6中的标志的按位或。
    int ai_family;/*地址族*/
    int ai_socktype;/*服务类型，SOCK_STREAM或SOCK_DGRAM*/
    int ai_protocol;
    //ai_protocol成员是指具体的网络协议，其含义和socket系统调用的第三个参数相同，它通常被设置为0。
    socklen_t ai_addrlen;/*socket地址ai_addr的长度*/
    char*ai_canonname;/*主机的别名*/
    struct sockaddr*ai_addr;/*指向socket地址*/
    struct addrinfo*ai_next;/*指向下一个sockinfo结构的对象*/
};
```

![表5-6 ai_flags成员](C:\Users\Administrator\Desktop\笔记\llinux服务器\表5-6 ai_flags成员.png)

当我们使用hints参数的时候，可以设置其ai_flags，ai_family， ai_socktype和ai_protocol四个字段，其他字段则必须被设置为NULL。

### getnameinfo

getnameinfo函数能通过socket地址同时获得以字符串表示的主机名 （内部使用的是gethostbyaddr函数）和服务名（内部使用的是 getservbyport函数）。它是否可重入取决于其内部调用的gethostbyaddr 和getservbyport函数是否是它们的可重入版本。

```C++
#include＜netdb.h＞
int getnameinfo(const struct sockaddr*sockaddr,socklen_t addrlen,char*host,socklen_t hostlen,char*serv,socklen_t servlen,int flags);
//getnameinfo将返回的主机名存储在host参数指向的缓存中，将服务 名存储在serv参数指向的缓存中，hostlen和servlen参数分别指定这两块缓存的长度。
//flags参数控制getnameinfo的行为，它可以接收表5-7中的选项。
```

![表5-7 flags参数](C:\Users\Administrator\Desktop\笔记\llinux服务器\表5-7 flags参数.png)

getaddrinfo和getnameinfo函数成功时返回0，失败则返回错误码， 可能的错误码如表5-8所示。

![表5-8 getaddrinfo和getnameinfo返回的错误码](C:\Users\Administrator\Desktop\笔记\llinux服务器\表5-8 getaddrinfo和getnameinfo返回的错误码.png)

# 第六章 高级IO函数

这些函数大致分为三类：

❑用于创建文件描述符的函数，包括pipe、dup/dup2函数。 
❑用于读写数据的函数，包括readv/writev、sendfile、 mmap/munmap、splice和tee函数。
❑用于控制I/O行为和属性的函数，包括fcntl函数。

## pipe函数

pipe函数可用于创建一个管道，以实现进程间通信。我们将在13.4 节讨论如何使用管道来实现进程间通信，本章只介绍其基本使用方 式。pipe函数的定义如下：

```C++
#include＜unistd.h＞
int pipe(int fd[2])
//pipe函数的参数是一个包含两个int型整数的数组指针。该函数成功时返回0，并将一对打开的文件描述符值填入其参数指向的数组。如果失败，则返回-1并设置errno。
```

通过pipe函数创建的这两个文件描述符fd[0]和fd[1]分别构成管道 的两端，往fd[1]写入的数据可以从fd[0]读出。并且，==fd[0]只能用于从 管道读出数据，fd[1]则只能用于往管道写入数据，而不能反过来使用。==

如果要实现双向的数据传输，就应该使用两个管道。默认情况 下，这一对文件描述符都是阻塞的。

此时如果我们用read系统调用来 读取一个空的管道，则read将被阻塞，直到管道内有数据可读；如果 我们用write系统调用来往一个满的管道（见后文）中写入数据，则 write亦将被阻塞，直到管道有足够多的空闲空间可用。

如果管道的写端文件描述符fd[1] 的引用计数（见5.7节）减少至0，即没有任何进程需要往管道中写入数据，则针对该管道的读端文件描述符fd[0]的read操作将返回0，即读取到了文件结束标记（End Of File，EOF）

反之，如果管道的读端文件描述符fd[0]的引用计数减少至0，即没有任何进程需要从管道读取数据，则针对该管道的写端文件描述符fd[1]的write操作将失败，并引 发SIGPIPE信号。

管道内部传输的数据是字节流，这和TCP字节流的概念相同。但 二者又有细微的区别。应用层程序能往一个TCP连接中写入多少字节 的数据，取决于对方的接收通告窗口的大小和本端的拥塞窗口的大 小。

此外，socket的基础API中有一个socketpair函数。==它能够方便地创 建双向管道。==其定义如下：

```C++
#include＜sys/types.h＞
#include＜sys/socket.h＞
int socketpair(int domain,int type,int protocol,int fd[2]);
//socketpair前三个参数的含义与socket系统调用的三个参数完全相同，但domain只能使用UNIX本地域协议族AF_UNIX，因为我们仅能在本地使用这个双向管道。
//最后一个参数则和pipe系统调用的参数一样，只不过socketpair创建的这对文件描述符都是既可读又可写的。socketpair成功时返回0，失败时返回-1并设置errno
```

## dup和dup2函数

有时我们希望把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接（比如CGI编程）。这可以通过下面的用于复制文件描述符的dup或dup2函数来实现：

```C++
#include＜unistd.h＞
int dup(int file_descriptor);
int dup2(int file_descriptor_one,int file_descriptor_two);
//dup函数创建一个新的文件描述符，该新文件描述符和原有文件描述符file_descriptor指向相同的文件、管道或者网络连接。
//并且dup返回的文件描述符总是取系统当前可用的最小整数值。
//dup2和dup类似，不过它将返回第一个不小于file_descriptor_two的整数值。
//dup和dup2系统调用失败时返回-1并设置errno。
//注意,通过dup和dup2创建的文件描述符并不继承原文件描述符的属性，比如close-on-exec和non-blocking等。
```

CGI服务器原理

```C++
#include＜sys/socket.h＞
#include＜netinet/in.h＞
#include＜arpa/inet.h＞
#include＜assert.h＞
#include＜stdio.h＞
#include＜unistd.h＞
#include＜stdlib.h＞
#include＜errno.h＞
#include＜string.h＞
int main(int argc,char*argv[])
{
    if(argc＜=2)
    {
        printf("usage:%s ip_address port_number\n",basename(argv[0]));
        return 1;
    }
    const char*ip=argv[1];
    int port=atoi(argv[2]);
    struct sockaddr_in address;
    bzero(＆address,sizeof(address));
    address.sin_family=AF_INET;
    inet_pton(AF_INET,ip,＆address.sin_addr);
    address.sin_port=htons(port);
    int sock=socket(PF_INET,SOCK_STREAM,0);
    assert(sock＞=0);
    int ret=bind(sock,(struct sockaddr*)＆address,sizeof(address));
    assert(ret!=-1);
    ret=listen(sock,5);
    assert(ret!=-1);
    struct sockaddr_in client;
    socklen_t client_addrlength=sizeof(client);
    int connfd=accept(sock,(struct sockaddr*)＆client,＆ client_addrlength);
    if(connfd＜0)
    {
    	printf("errno is:%d\n",errno);
    }
    else
    {
        close(STDOUT_FILENO);//先关闭标准输出文件描述符STDOUT_FILENO（其值是1）
        dup(connfd);//然后复制socket文件描述符connfd。
        //因为dup总是返回系统中最小的可用文件描述符，所以它的返回值实际上是1，即之前关闭的标准输出文件描述符的值。
        printf("abcd\n");
        close(connfd);
        //这样一来，服务器输出到标准输出的内容（这里是“abcd”）就会直接发送到与客户连接对应的socket上，因此printf调用的输出将被客户端获得（而不是显示在服务器程序的终端上）。这就是CGI服务器的基本工作原理。
    }
    	close(sock);
    return 0;
}
```

## readv函数和writev函数

readv函数将数据从文件描述符读到分散的内存块中，即分散读；
writev函数则将多块分散的内存数据一并写入文件描述符中，即集中 写。

```C++
#include＜sys/uio.h＞
ssize_t readv(int fd,const struct iovec*vector,int count)；
ssize_t writev(int fd,const struct iovec*vector,int count);
//fd参数是被操作的目标文件描述符。vector参数的类型是iovec结构数组。
//count参数是vector数组的长度，即有多少块内存数据需要从fd读出或 写到fd。
//readv和writev在成功时返回读出/写入fd的字节数，失败则返 回-1并设置errno。
```

==它们相当于简化版的recvmsg和sendmsg函数==

当Web服务器解析完一个HTTP 请求之后，如果目标文档存在且客户具有读取该文档的权限，那么它 就需要发送一个HTTP应答来传输该文档。这个HTTP应答包含1个状态 行、多个头部字段、1个空行和文档的内容。其中，前3部分的内容可 能被Web服务器放置在一块内存中，==而文档的内容则通常被读入到另外一块单独的内存中（通过read函数或mmap函数）。==我们并不需要把这两部分内容拼接到一起再发送，而是==可以使用writev函数将它们同时写出，如代码清单6-2所示。==

```C++
#include＜sys/socket.h＞
#include＜netinet/in.h＞
#include＜arpa/inet.h＞
#include＜assert.h＞
#include＜stdio.h＞
#include＜unistd.h＞
#include＜stdlib.h＞
#include＜errno.h＞
#include＜string.h＞
#include＜sys/stat.h＞
#include＜sys/types.h＞
#include＜fcntl.h＞
#define BUFFER_SIZE 1024
/*定义两种HTTP状态码和状态信息*/
static const char*status_line[2]={"200 OK","500 Internal server error"};
int main(int argc,char*argv[])
{
    if(argc＜=3)
    {
        printf("usage:%s ip_address port_number filename\n",basename(argv[0]));
        return 1;
    }
    const char*ip=argv[1];
    int port=atoi(argv[2]);
    /*将目标文件作为程序的第三个参数传入*/
    const char*file_name=argv[3];
    struct sockaddr_in address;
    bzero(＆address,sizeof(address));
    address.sin_family=AF_INET;
    inet_pton(AF_INET,ip,＆address.sin_addr);
    address.sin_port=htons(port);
    int sock=socket(PF_INET,SOCK_STREAM,0);
    assert(sock＞=0);
    int ret=bind(sock,(struct sockaddr*)＆address,sizeof(address));
    assert(ret!=-1);
    ret=listen(sock,5);
    assert(ret!=-1);
    struct sockaddr_in client;
    socklen_t client_addrlength=sizeof(client);
    int connfd=accept(sock,(struct sockaddr*)＆client,＆client_addrlength);
    if(connfd＜0)
    {
    	printf("errno is:%d\n",errno);
    }
    else
    {
        /*用于保存HTTP应答的状态行、头部字段和一个空行的缓存区*/
        char header_buf[BUFFER_SIZE];
        memset(header_buf,'\0',BUFFER_SIZE);
        /*用于存放目标文件内容的应用程序缓存*/
        char*file_buf;
        /*用于获取目标文件的属性，比如是否为目录，文件大小等*/
        struct stat file_stat;
        /*记录目标文件是否是有效文件*/
        bool valid=true;
        /*缓存区header_buf目前已经使用了多少字节的空间*/
        int len=0;
        if(stat(file_name,＆file_stat)＜0)/*目标文件不存在*/
        {
            valid=false;
        }
        else
        {
            if(S_ISDIR(file_stat.st_mode))/*目标文件是一个目录*/
            {
            	valid=false;
            }
            else if(file_stat.st_mode＆S_IROTH)/*当前用户有读取目标文件的权限*/
            {
                /*动态分配缓存区file_buf，并指定其大小为目标文件的大小file_stat.st_size
                加1，然后将目标文件读入缓存区file_buf中*/
                int fd=open(file_name,O_RDONLY);
                file_buf=new char[file_stat.st_size+1];
                memset(file_buf,'\0',file_stat.st_size+1);
                if(read(fd,file_buf,file_stat.st_size)＜0)
                {
                    valid=false;
                }
    		}
            else
            {
            valid=false;
            }
    	}
        /*如果目标文件有效，则发送正常的HTTP应答*/
        if(valid)
        {
            /*下面这部分内容将HTTP应答的状态行、“Content-Length”头部字段和一个空行依
            次加入header_buf中*/
            ret=snprintf(header_buf,BUFFER_SIZE1,"%s%s\r\n","HTTP/1.1",status_line[0]);
            len+=ret;
            ret=snprintf(header_buf+len,BUFFER_SIZE-1-len,"ContentLength:%d\r\n",file_stat.st_size);
            len+=ret;
            ret=snprintf(header_buf+len,BUFFER_SIZE-1-len,"%s","\r\n");
            /*利用writev将header_buf和file_buf的内容一并写出*/
            struct iovec iv[2];
            iv[0].iov_base=header_buf;
            iv[0].iov_len=strlen(header_buf);
            iv[1].iov_base=file_buf;
            iv[1].iov_len=file_stat.st_size;
            ret=writev(connfd,iv,2);
        }
        else/*如果目标文件无效，则通知客户端服务器发生了“内部错误”*/
        {
            ret=snprintf(header_buf,BUFFER_SIZE1,"%s%s\r\n","HTTP/1.1",status_line[1]);
            len+=ret;
            ret=snprintf(header_buf+len,BUFFER_SIZE-1-len,"%s","\r\n");
            send(connfd,header_buf,strlen(header_buf),0);
        }
        close(connfd);
        delete[]file_buf;
    }
    close(sock);
    return 0;
}
```

我们省略了HTTP请求的接收及解析，因为现在 关注的重点是HTTP应答的发送。==我们直接将目标文件作为第3个参数 传递给服务器程序，客户telnet到该服务器上即可获得该文件。==

## sendfile函数

==sendfile函数在两个文件描述符之间直接传递数据（完全在内核中 操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率 很高==，这被称为==零拷贝==。sendfile函数的定义如下：

```C++
#include＜sys/sendfile.h＞
ssize_t sendfile(int out_fd,int in_fd,off_t*offset,size_t count);
//in_fd参数是待读出内容的文件描述符，out_fd参数是待写入内容的文件描述符。
//offset参数指定从读入文件流的哪个位置开始读，如果为空，则使用读入文件流默认的起始位置。
//count参数指定在文件描述符in_fd和out_fd之间传输的字节数。
//sendfile成功时返回传输的字节数，失败则返回-1并设置errno。

//in_fd必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket和管道；而out_fd则必须是一个socket。由此可见，sendfile几乎是专门为在网络上传输文件而设计的。
```

### 用sendfile发送文件

```C++
#include＜sys/socket.h＞
#include＜netinet/in.h＞
#include＜arpa/inet.h＞
#include＜assert.h＞
#include＜stdio.h＞
#include＜unistd.h＞
#include＜stdlib.h＞
#include＜errno.h＞
#include＜string.h＞
#include＜sys/types.h＞
#include＜sys/stat.h＞
#include＜fcntl.h＞
#include＜sys/sendfile.h＞
int main(int argc,char*argv[])
{
    if(argc＜=3)
    {
        printf("usage:%s ip_address port_number filename\n",basename(argv[0]));
        return 1;
    }
    const char*ip=argv[1];
    int port=atoi(argv[2]);
    const char*file_name=argv[3];
    int filefd=open(file_name,O_RDONLY);
    assert(filefd＞0);
    struct stat stat_buf;
    fstat(filefd,＆stat_buf);
    struct sockaddr_in address;
    bzero(＆address,sizeof(address));
    address.sin_family=AF_INET;
    inet_pton(AF_INET,ip,＆address.sin_addr);
    address.sin_port=htons(port);
    int sock=socket(PF_INET,SOCK_STREAM,0);
    assert(sock＞=0);
    int ret=bind(sock,(struct sockaddr*)＆address,sizeof(address));
    assert(ret!=-1);
    ret=listen(sock,5);
    assert(ret!=-1);
    struct sockaddr_in client;
    socklen_t client_addrlength=sizeof(client);
    int connfd=accept(sock,(struct sockaddr*)＆client,＆ client_addrlength);
    if(connfd＜0)
    {
    	printf("errno is:%d\n",errno);
    }
    else
    {
        sendfile(connfd,filefd,NULL,stat_buf.st_size);
        close(connfd);
    }
    close(sock);
    return 0;
}
```

## mmap函数和munmap函数

mmap函数用于申请一段内存空间。我们可以将这段内存作为进程 间通信的共享内存，也可以将文件直接映射到其中。munmap函数则释 放由mmap创建的这段内存空间。

```C++
#include＜sys/mman.h＞
void*mmap(void*start,size_t length,int prot,int flags,int fd,off_t offset);
int munmap(void*start,size_t length);
//start参数允许用户使用某个特定的地址作为这段内存的起始地址。如果它被设置成NULL，则系统自动分配一个地址。
//length参数指定内存段的长度。
//prot参数用来设置内存段的访问权限。它可以取以下几个值的按位或：
/*
❑PROT_READ，内存段可读。
❑PROT_WRITE，内存段可写。
❑PROT_EXEC，内存段可执行。
❑PROT_NONE，内存段不能被访问。
*/
//flags参数控制内存段内容被修改后程序的行为。它可以被设置为表6-1中的某些值（这里仅列出了常用的值）的按位或（其中MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定）。
//fd参数是被映射文件对应的文件描述符。它一般通过open系统调用获得。
//offset参数设置从文件的何处开始映射
```

![表6-1 mmap的flags参数的常用值及其含义](C:\Users\Administrator\Desktop\笔记\llinux服务器\表6-1 mmap的flags参数的常用值及其含义.png)

## splice函数

splice函数用于在两个文件描述符之间移动数据，也是零拷贝操作。

```C++
#include＜fcntl.h＞
ssize_t splice(int fd_in,loff_t*off_in,int fd_out,loff_t*off_out,size_t len,unsigned int flags);
//fd_in参数是待输入数据的文件描述符。
//如果fd_in是一个管道文件描述符，那么off_in参数必须被设置为NULL。
//如果fd_in不是一个管道文件描述符（比如socket），那么off_in表示从输入数据流的何处开始读取数据。此时，若off_in被设置为NULL，则表示从输入数据流的当前偏移位置读入；若off_in不为NULL，则它将指出具体的偏移位置。
//fd_out/off_out参数的含义与fd_in/off_in相同，不过用于输出数据流。
//len参数指定移动数据的长度
//flags参数则控制数据如何移动，它可以被设置为表6-2中的某些值的按位或
```

![表6-2 splice的flags参数的常用值及其含义](C:\Users\Administrator\Desktop\笔记\llinux服务器\表6-2 splice的flags参数的常用值及其含义.png)

使用splice函数时，==fd_in和fd_out必须至少有一个是管道文件描述符。==splice函数调用成功时返回移动字节的数量。它可能返回0，表示没 有数据需要移动，这发生在从管道中读取数据（fd_in是管道文件描述 符）而该管道没有被写入任何数据时。splice函数失败时返回-1并设置 errno。

![表6-3 splice函数可能产生的errno及其含义](C:\Users\Administrator\Desktop\笔记\llinux服务器\表6-3 splice函数可能产生的errno及其含义.png)

### 使用splice函数实现的回射服务器

```C++
#include＜sys/socket.h＞
#include＜netinet/in.h＞
#include＜arpa/inet.h＞
#include＜assert.h＞
#include＜stdio.h＞
#include＜unistd.h＞
#include＜stdlib.h＞
#include＜errno.h＞
#include＜string.h＞
#include＜fcntl.h＞
int main(int argc,char*argv[])
{
    if(argc＜=2)
    {
        printf("usage:%s ip_address port_number\n",basename(argv[0]));
        return 1;
    }
    const char*ip=argv[1];
    int port=atoi(argv[2]);
    struct sockaddr_in address;
    bzero(＆address,sizeof(address));
    address.sin_family=AF_INET;
    inet_pton(AF_INET,ip,＆address.sin_addr);
    address.sin_port=htons(port);
    int sock=socket(PF_INET,SOCK_STREAM,0);
    assert(sock＞=0);
    int ret=bind(sock,(struct sockaddr*)＆address,sizeof(address));
    assert(ret!=-1);
    ret=listen(sock,5);
    assert(ret!=-1);
    struct sockaddr_in client;
    socklen_t client_addrlength=sizeof(client);
    int connfd=accept(sock,(struct sockaddr*)＆client,＆ client_addrlength);
    if(connfd＜0)
    {
    	printf("errno is:%d\n",errno);
    }
    else
    {
        int pipefd[2];
        assert(ret!=-1);
        ret=pipe(pipefd);/*创建管道*/
        /*将connfd上流入的客户数据定向到管道中*/
        ret=splice(connfd,NULL,pipefd[1],NULL,32768,SPLICE_F_MORE|SPLICE_F_MOVE);
        assert(ret!=-1);
        /*将管道的输出定向到connfd客户连接文件描述符*/
        ret=splice(pipefd[0],NULL,connfd,NULL,32768,SPLICE_F_MORE|SPLICE_F_MOVE);
        assert(ret!=-1);
        close(connfd);
    }
    close(sock);
    return 0;
}
```

我们通过splice函数将客户端的内容读入到pipefd[1]中，然后再使用splice函数从pipefd[0]中读出该内容到客户端，从而实现了简单高效的回射服务。==整个过程未执行recv/send操作，因此也未涉及用户空间和内核空间之间的数据拷贝==



## tee函数

tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作。==它不消耗数据==，因此源文件描述符上的数据仍然可以用于后续的读操 作。tee函数的原型如下

```C++
#include＜fcntl.h＞
ssize_t tee(int fd_in,int fd_out,size_t len,unsigned int flags)
//该函数的参数的含义与splice相同（但fd_in和fd_out必须都是管道文件描述符）。
//tee函数成功时返回在两个文件描述符之间复制的数据数量（字节数）。返回0表示没有复制任何数据。tee失败时返回-1并设置errno。
```

### 利用tee函数和splice函数，实现了Linux下tee程序的基本功能

```C++
#include＜assert.h＞
#include＜stdio.h＞
#include＜unistd.h＞
#include＜errno.h＞
#include＜string.h＞
#include＜fcntl.h＞
int main(int argc,char*argv[])
{
    if(argc!=2)
    {
        printf("usage:%s＜file＞\n",argv[0]);
        return 1;
    }
    int filefd=open(argv[1],O_CREAT|O_WRONLY|O_TRUNC,0666);
    assert(filefd＞0);
    int pipefd_stdout[2];
    int ret=pipe(pipefd_stdout);
    assert(ret!=-1);
    int pipefd_file[2];
    ret=pipe(pipefd_file);
    assert(ret!=-1);
    /*将标准输入内容输入管道pipefd_stdout*/
    ret=splice(STDIN_FILENO,NULL,pipefd_stdout[1],NULL,32768,SPLICE_F_MORE|SPLICE_F_MOVE);
    assert(ret!=-1);
    /*将管道pipefd_stdout的输出复制到管道pipefd_file的输入端*/
    ret=tee(pipefd_stdout[0],pipefd_file[1],32768,SPLICE_F_NONBLOCK);
    assert(ret!=-1);
    /*将管道pipefd_file的输出定向到文件描述符filefd上，从而将标准输入的内容写入文件*/
    ret=splice(pipefd_file[0],NULL,filefd,NULL,32768,SPLICE_F_MORE|S
    PLICE_F_MOVE);
    assert(ret!=-1);
    /*将管道pipefd_stdout的输出定向到标准输出，其内容和写入文件的内容完全一致*/
    ret=splice(pipefd_stdout[0],NULL,STDOUT_FILENO,NULL,32768,SPLICE _F_MORE|SPLICE_F_MOVE);
    assert(ret!=-1);
    close(filefd);
    close(pipefd_stdout[0]);
    close(pipefd_stdout[1]);
    close(pipefd_file[0]);
    close(pipefd_file[1]);
    return 0;
}
```

## fcntl函数

fcntl函数，正如其名字（file control）描述的那样，==提供了对文件描述符的各种控制操作。==另外一个常见的控制文件描述符属性和行为的系统调用是ioctl，而且ioctl比fcntl能够执行更多的控制。但是，对于 控制文件描述符常用的属性和行为，fcntl函数是由POSIX规范指定的首选方法。

```C++
#include＜fcntl.h＞
int fcntl(int fd,int cmd,…);
//fd参数是被操作的文件描述符
//cmd参数指定执行何种类型的操作。
//根据操作类型的不同，该函数可能还需要第三个可选参数arg。
```

![表6-4 fcntl支持的常用操作及其参数](C:\Users\Administrator\Desktop\笔记\llinux服务器\表6-4 fcntl支持的常用操作及其参数.png)

fcntl函数成功时的返回值如表6-4最后一列所示，失败则返回-1并 设置errno。

==fcntl函数通常用来将一个文件描述符设置为非阻塞的==，如代码清单6-6所示。

```C++
int setnonblocking(int fd)
{
    int old_option=fcntl(fd,F_GETFL);/*获取文件描述符旧的状态标志*/
    int new_option=old_option|O_NONBLOCK;/*设置非阻塞标志*/
    fcntl(fd,F_SETFL,new_option);
    return old_option;/*返回文件描述符旧的状态标志，以便日后恢复该状态标志*/
}
```

# 第七章 Linux服务器规范

除了网络通信外，服务器程序通常还必须考虑许多其他细节问 题。这些细节问题涉及面广且零碎，而且基本上是模板式的，所以我们称之为服务器程序规范。

==①Linux服务器程序一般以后台进程形式运行。==后台进程又称守护 进程（daemon）。它没有控制终端，因而也不会意外接收到用户输 入。守护进程的父进程通常是init进程（PID为1的进程）。

==②Linux服务器程序通常有一套日志系统，==它至少能输出日志到文 件，有的高级服务器还能输出日志到专门的UDP服务器。大部分后台 进程都在/var/log目录下拥有自己的日志目录。

==③Linux服务器程序一般以某个专门的非root身份运行。==比如 mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户mysql、 apache和syslog。

==④Linux服务器程序通常是可配置的。==服务器程序通常能处理很多 命令行选项，如果一次运行的选项太多，则可以用配置文件来管理。 绝大多数服务器程序都有配置文件，并存放在/etc目录下。比如第4章 讨论的squid服务器的配置文件是/etc/squid3/squid.conf。

## 日志

### Linux日志系统

Linux提供一个守护进程来处理系统日志——syslogd，不过现在的Linux系统上使用的都是它的升级版——rsyslogd。

rsyslogd守护进程既能接收用户进程输出的日志，又能接收内核日志。

### 用户进程日志

用户进程是通过调用syslog函数生成系统日志的。该函数将日志输出到一个UNIX本地域socket类型（AF_UNIX）的文件/dev/log中， rsyslogd则监听该文件以获取用户进程的输出。

### 内核日志

内核日志在老的系统上是通过另外一个守护进程rklogd来管理的，rsyslogd利用额外的模块实现了相同的功能。内核日志由printk等函数打印至内核的环状缓存 （ring buffer）中。环状缓存的内容直接映射到/proc/kmsg文件中。 rsyslogd则通过读取该文件获得内核日志。

### 日志文件

rsyslogd守护进程在接收到用户进程或内核输入的日志后，会把它 们输出至某些特定的日志文件。

==默认情况下，调试信息会保存 至/var/log/debug文件，普通信息保存至/var/log/messages文件，==内核消 息则保存至/var/log/kern.log文件。不过，日志信息具体如何分发，可以 在rsyslogd的配置文件中设置。rsyslogd的主配置文件 是/etc/rsyslog.conf，其中主要可以设置的项包括：内核日志输入路径， 是否接收UDP日志及其监听端口（默认是514，见/etc/services文件）， 是否接收TCP日志及其监听端口，日志文件的权限，包含哪些子配置文 件（比如/etc/rsyslog.d/*.conf）。rsyslogd的子配置文件则指定各类日志的目标存储文件

![图7-1 Linux系统日志](C:\Users\Administrator\Desktop\笔记\llinux服务器\图7-1 Linux系统日志.png)

### syslog函数

应用程序使用syslog函数与rsyslogd守护进程通信。syslog函数的定义如下

```C++
#include＜syslog.h＞
void syslog(int priority,const char*message,...);
//该函数采用可变参数（第二个参数message和第三个参数…）来结构化输出
//priority参数是所谓的设施值与日志级别的按位或。设施值的默认值是LOG_USER，我们下面的讨论也只限于这一种设施值。日志级别有如下几个：

#include＜syslog.h＞
#define LOG_EMERG 0/*系统不可用*/
#define LOG_ALERT 1/*报警，需要立即采取动作*/
#define LOG_CRIT 2/*非常严重的情况*/
#define LOG_ERR 3/*错误*/
#define LOG_WARNING 4/*警告*/
#define LOG_NOTICE 5/*通知*/
#define LOG_INFO 6/*信息*/
#define LOG_DEBUG 7/*调试*/
```

下面这个函数可以==改变syslog的默认输出方式，==进一步结构化日志 内容：

```C++
#include＜syslog.h＞
void openlog(const char*ident,int logopt,int facility);
//ident参数指定的字符串将被添加到日志消息的日期和时间之后，它通常被设置为程序的名字。
//logopt参数对后续syslog调用的行为进行配置，它可取下列值的按位或：
#define LOG_PID 0x01/*在日志消息中包含程序PID*/
#define LOG_CONS 0x02/*如果消息不能记录到日志文件，则打印至终端*/
#define LOG_ODELAY 0x04/*延迟打开日志功能直到第一次调用syslog*/
#define LOG_NDELAY 0x08/*不延迟打开日志功能*/
//facility参数可用来修改syslog函数中的默认设施值。
```

### 日志的过滤

程序在开发阶段可能需要输出很多 调试信息，而发布之后我们又需要将这些调试信息关闭。解决这个问 题的方法并不是在程序发布之后删除调试代码（因为日后可能还需要 用到），而是简单地==设置日志掩码，使日志级别大于日志掩码的日志信息被系统忽略。==

```C++
#include＜syslog.h＞
int setlogmask(int maskpri);
//maskpri参数指定日志掩码值。该函数始终会成功，它返回调用进程先前的日志掩码值
```

### 关闭日志

```C++
#include＜syslog.h＞
void closelog();
```

## 用户信息

### UID、EUID、GID和EGID

用户信息对于服务器程序的安全性来说是很重要的，比如大部分 服务器就必须以root身份启动，但不能以root身份运行。

下面这一组函 数可以获取和设置当前进程的真实用户ID（UID）、有效用户 ID（EUID）、真实组ID（GID）和有效组ID（EGID）：

```C++
#include＜sys/types.h＞
#include＜unistd.h＞
uid_t getuid();/*获取真实用户ID*/
uid_t geteuid();/*获取有效用户ID*/
gid_t getgid();/*获取真实组ID*/
gid_t getegid();/*获取有效组ID*/
int setuid(uid_t uid);/*设置真实用户ID*/
int seteuid(uid_t uid);/*设置有效用户ID*/
int setgid(gid_t gid);/*设置真实组ID*/
int setegid(gid_t gid);/*设置有效组ID*/
```

### UID和EUID

需要指出的是，一个进程拥有两个用户ID：UID和EUID。

EUID 存在的目的是方便资源访问：它使得运行程序的用户拥有该程序的有 效用户的权限。比如su程序，任何用户都可以使用它来修改自己的账户信息，但修改账户时su程序不得不访问/etc/passwd文件，而访问该文件是需要root权限的。

==那么以普通用户身份启动的su程序如何能访 问/etc/passwd文件呢？窍门就在EUID。==

用ls命令可以查看到，su程序的所有者是root，并且它被设置了set-user-id标志。这个标志表示，任 何普通用户运行su程序时，其有效用户就是该程序的所有者root。那 么，根据有效用户的含义，任何运行su程序的普通用户都能够访 问/etc/passwd文件。有效用户为root的进程称为特权进程（privileged processes）。==EGID的含义与EUID类似：给运行目标程序的组用户提 供有效组的权限。==

### 测试进程的UID和EUID的区别

```C++
#include＜unistd.h＞
#include＜stdio.h＞
int main()
{
    uid_t uid=getuid();
    uid_t euid=geteuid();
    printf("userid is%d,effective userid is:%d\n",uid,euid);
    return 0;
}
```

编译该文件，将生成的可执行文件（名为test_uid）的所有者设置为root，并设置该文件的set-user-id标志，然后运行该程序以查看UID 和EUID。具体操作如下

```bash
$sudo chown root:root test_uid#修改目标文件的所有者为root
$sudo chmod+s test_uid#设置目标文件的set-user-id标志
$./test_uid#运行程序
userid is 1000,effective userid is:0
```

从测试程序的输出来看，进程的UID是启动程序的用户的ID，而 EUID则是root账户（文件所有者）的ID。

### 切换用户

如何将以root身份启动的进程切换为以 一个普通用户身份运行。

```C++
static bool switch_to_user(uid_t user_id,gid_t gp_id)//输入的参数是想改变的ID
{
    /*先确保目标用户不是root*/
    if((user_id==0)＆＆(gp_id==0))
    {
    	return false;
    }
    /*确保当前用户是合法用户：root或者目标用户*/
    gid_t gid=getgid();
    uid_t uid=getuid();
    if(((gid!=0)||(uid!=0))＆＆((gid!=gp_id)||(uid!=user_id)))
    {
    	return false;
    }
    /*如果不是root，则已经是目标用户*/
    if(uid!=0)
    {
    	return true;
    }
    /*切换到目标用户*/
    if((setgid(gp_id)＜0)||(setuid(user_id)＜0))
    {
    	return false;
    }
    return true;
}
```

## 进程间关系

### 进程组

Linux下每个进程都隶属于一个进程组，因此它们除了PID信息 外，还有进程组ID（PGID）。我们可以用如下函数来获取指定进程的 PGID：

```C++
#include＜unistd.h＞
pid_t getpgid(pid_t pid);
//该函数成功时返回进程pid所属进程组的PGID，失败则返回-1并设置errno。
```

==每个进程组都有一个首领进程，其PGID和PID相同。==进程组将一 直存在，直到其中所有进程都退出，或者加入到其他进程组。

```C++
#include＜unistd.h＞
int setpgid(pid_t pid,pid_t pgid);
//该函数将PID为pid的进程的PGID设置为pgid。如果pid和pgid相同，则由pid指定的进程将被设置为进程组首领；
//如果pid为0，则表示设置当前进程的PGID为pgid；
//如果pgid为0，则使用pid作为目标PGID。
//setpgid函数成功时返回0，失败则返回-1并设置errno。
```

==一个进程只能设置自己或者其子进程的PGID。==并且，当子进程调 用exec系列函数后，我们也不能再在父进程中对它设置PGID。

### 会话

一些有关联的进程组将形成一个会话（session）。

```C++
#include＜unistd.h＞
pid_t setsid(void);
//用于创建一个会话
//该函数成功时返回新的进程组的PGID，失败则返回-1并设置errno。
/*
该函数不能由进程组的首领进程调用，否则将产生一个错误。对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果：
❑调用进程成为会话的首领，此时该进程是新会话的唯一成员。
❑新建一个进程组，其PGID就是调用进程的PID，调用进程成为该
组的首领。
❑调用进程将甩开终端（如果有的话）。
*/
```

Linux进程并未提供所谓会话ID（SID）的概念，但Linux系统认为 它等于会话首领所在的进程组的PGID，并提供了如下函数来==读取 SID：==

```C++
#include＜unistd.h＞
pid_t getsid(pid_t pid);
```

### 用ps命令查看进程关系

```BASH
$ps-o pid,ppid,pgid,sid,comm|less
PID PPID PGID SID COMMAND
1943 1942 1943 1943 bash
2298 1943 2298 1943 ps
2299 1943 2298 1943 less
```

我们是在bash shell下执行ps和less命令的，所以ps和less命令的父进程是bash命令，这可以从==PPID（父进程PID）==一列看出。
这3条命令创 建了1个会话（SID是1943）和2个进程组（PGID分别是1943和 2298）。
bash命令的PID、PGID和SID都相同，很明显它既是会话的首 领，也是组1943的首领。ps命令则是组2298的首领，因为其PID也是 2298。

![图7-2 进程间关系](C:\Users\Administrator\Desktop\笔记\llinux服务器\图7-2 进程间关系.png)

## 系统资源限制

Linux上运行的程序都会受到资源限制的影响，比如物理设备限制 （CPU数量、内存数量等）、系统策略限制（CPU时间等），以及具 体实现的限制（比如文件名的最大长度）。Linux系统资源限制可以通 过如下一对函数来读取和设置：

```C++
#include＜sys/resource.h＞
int getrlimit(int resource,struct rlimit*rlim);
int setrlimit(int resource,const struct rlimit*rlim);
//setrlimit和getrlimit成功时返回0，失败则返回-1并设置errno。
//resource参数指定资源限制类型。
//rlim参数是rlimit结构体类型的指针，rlimit结构体的定义如下：
struct rlimit
{
    rlim_t rlim_cur;
    rlim_t rlim_max;
};
//rlim_t是一个整数类型，它描述资源级别。
//rlim_cur成员指定资源的软限制。
//rlim_max成员指定资源的硬限制。
```

### 软限制

软限制是一个建议性的、最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其运行。

例如，当进程CPU时间超过其软限制时，系统将向进 程发送SIGXCPU信号；当文件尺寸超过其软限制时，系统将向进程发 送SIGXFSZ信号（见第10章）。

### 硬限制

硬限制一般是软限制的上限。普通程 序可以减小硬限制，而只有以root身份运行的程序才能增加硬限制。

此外，我们可以使用ulimit命令修改当前shell环境下的资源限制（软限制 或/和硬限制），这种修改将对该shell启动的所有后续程序有效。我们 也可以通过修改配置文件来改变系统软限制和硬限制，而且这种修改 是永久的，详情见第16章。

### 资源限制类型

![表7-1 getrlimit和setlimit支持的部分资源限制类型](C:\Users\Administrator\Desktop\笔记\llinux服务器\表7-1 getrlimit和setlimit支持的部分资源限制类型.png)

## 改变工作目录和根目录

有些服务器程序还需要改变工作目录和根目录，比如我们第4章讨 论的Web服务器。一般来说，Web服务器的逻辑根目录并非文件系统 的根目录“/”，而是站点的根目录（对于Linux的Web服务来说，该目录 一般是/var/www/）

```C++
#include＜unistd.h＞
char*getcwd(char*buf,size_t size); //获取进程当前工作目录
int chdir(const char*path); //改变进程工作目录
//buf参数指向的内存用于存储进程当前工作目录的绝对路径名，其大小由size参数指定。
//如果当前工作目录的绝对路径的长度（再加上一个空结束字符“\0”）超过了size，则getcwd将返回NULL，并设置errno为ERANGE。
//如果buf为NULL并且size非0，则getcwd可能在内部使用malloc动态分配内存，并将进程的当前工作目录存储在其中。
//如果是这种情况，则我们必须自己来释放getcwd在内部创建的这块内存。
//getcwd函数成功时返回一个指向目标存储区（buf指向的缓存区或是getcwd在内部动态创建的缓存区）的指针，失败则返回NULL并设置errno

//chdir函数的path参数指定要切换到的目标目录。它成功时返回0，失败时返回-1并设置errno。
```

==改变进程根目录的函数是chroot，==其定义如下：

```C++
#include＜unistd.h＞
int chroot(const char*path);
//path参数指定要切换到的目标根目录。它成功时返回0，失败时返回-1并设置errno。
//chroot并不改变进程的当前工作目录，所以调用chroot之后，我们仍然需要使用chdir(“/”)来将工作目录切换至新的根目录。
```

改变进程的根目录之后，程序可能无法访问类似/dev的文件（和目录），因为这些文件（和目录）并非处于新的根目录之下。不过好
在调用chroot之后，==进程原先打开的文件描述符依然生效，所以我们可以利用这些早先打开的文件描述符来访问调用chroot之后不能直接访问的文件（和目录）==，尤其是一些日志文件。此外，只有特权进程才能改变根目录。

## 服务器程序后台化

如何在代码中让一个进程以守护进程的方式运 行。守护进程的编写遵循一定的步骤[2]，下面我们通过一个具体实现 来探讨，如代码清单7-3所示

```C++
bool daemonize()
{
    /*创建子进程，关闭父进程，这样可以使程序在后台运行*/
    pid_t pid=fork();
    if(pid＜0)
    {
    	return false;
    }
    else if(pid＞0)
    {
    	exit(0);
    }
    /*设置文件权限掩码。当进程创建新文件（使用open(const char*pathname,intflags,mode_t mode)系统调用）时，文件的权限将是mode＆0777*/
    umask(0);
    /*创建新的会话，设置本进程为进程组的首领*/
    pid_t sid=setsid();
    if(sid＜0)
    {
    	return false;
    }
    /*切换工作目录*/
    if((chdir("/"))＜0)
    {
    	return false;
    }
    /*关闭标准输入设备、标准输出设备和标准错误输出设备*/
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
    /*关闭其他已经打开的文件描述符，代码省略*/
    /*将标准输入、标准输出和标准错误输出都定向到/dev/null文件*/
    open("/dev/null",O_RDONLY);
    open("/dev/null",O_RDWR);
    open("/dev/null",O_RDWR);
    return true;
}
```

### 实际上linux也有库函数

```C++
#include＜unistd.h＞
int daemon(int nochdir,int noclose);
//nochdir参数用于指定是否改变工作目录，如果给它传递0，则工作目录将被设置为“/”（根目录），否则继续使用当前工作目录。
//noclose参数为0时，标准输入、标准输出和标准错误输出都被重定向到/dev/null文件，否则依然使用原来的设备。
//该函数成功时返回0，失败则返回-1并设置errno。
```

# 第八章 高性能服务器框架

按照服务器程序的一般原理，将服务器解构为如下三个主要模块： 
❑==I/O处理单元。==本章将介绍I/O处理单元的四种I/O模型和两种高 效事件处理模式。 
❑==逻辑单元。==本章将介绍逻辑单元的两种高效并发模式，以及高 效的逻辑处理方式——有限状态机。
❑==存储单元。==本书不讨论存储单元，因为它只是服务器程序的可选模块，而且其内容与网络编程本身无关。

## 服务器模型

### C/S模型

TCP/IP协议在设计和实现上并没有客户端和服务器的概念，在通信过程中所有机器都是对等的。但由于资源（视频、新闻、软件等） 都被数据提供者所垄断，所以==几乎所有的网络应用程序都很自然地采用了C/S（客户端/服务器）模型：所有客户端都通过访问服务器来获取所需的资源。==

C/S模型的逻辑很简单。服务器启动后，
a、首先创建一个（或多个） 监听socket，
b、并调用bind函数将其绑定到服务器感兴趣的端口上，
c、然后调用listen函数等待客户连接。服务器稳定运行之后，客户端就可以调 用connect函数向服务器发起连接了。

由于客户连接请求是==随机到达的异步事件，==服务器需要使用某种I/O模型来监听这一事件。I/O模型有多种

![图8-2 TCP服务器和TCP客户端的工作流程](C:\Users\Administrator\Desktop\笔记\llinux服务器\图8-2 TCP服务器和TCP客户端的工作流程.png)

在上图中，服务器使用的是I/O复用技术之一的==select系统调用。==当 监听到连接请求后，服务器就调用accept函数接受它，并分配一个逻辑 单元为新的连接服务。逻辑单元可以是新创建的子进程、子线程或者其他。

图8-2中，服务器给客户端分配的逻辑单元是==由fork系统调用创建的子进程。==逻辑单元读取客户请求，处理该请求，然后将处理结果 返回给客户端。客户端接收到服务器反馈的结果之后，可以继续向服 务器发送请求，也可以立即主动关闭连接。如果客户端主动关闭连 接，则服务器执行被动关闭连接。至此，双方的通信结束。

需要注意的是，服务器在处理一个客户请求的同时还会继续监听其他客户请求，否则就变成了效率低下的串行服务器了（必须先处理完前一个客 户的请求，才能继续处理下一个客户请求）。

上图中服务器同时监听多个客户请求是通过select系统调用实现的

C/S模型非常适合资源相对集中的场合，并且它的实现也很简单， 但其==缺点也很明显：服务器是通信的中心，当访问量过大时，可能所 有客户都将得到很慢的响应。==下面讨论的P2P模型解决了这个问题

## P2P模型

P2P（Peer to Peer，点对点）模型比C/S模型更符合网络通信的实 际情况。它摒弃了以服务器为中心的格局，==让网络上所有主机重新回归对等的地位。==

P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样 资源能够充分、自由地共享。云计算机群可以看作P2P模型的一个典 范。但P2P模型的==缺点也很明显：当用户之间传输的请求过多时，网络的负载将加重。==

P2P模型存在一个显著的问题，即==主机之间很难互相发现。==所以实际使用的P2P模型通常带有一个==专门的发现服务器，==如图 8-3b所示。这个发现服务器通常还提供查找服务（甚至还可以提供内容 服务），使每个客户都能尽快地找到自己需要的资源。

![图8-3 两种p2p模型](C:\Users\Administrator\Desktop\笔记\llinux服务器\图8-3 两种p2p模型.png)

## 服务器编程框架

虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理。

![图8-4 服务器基本框架](C:\Users\Administrator\Desktop\笔记\llinux服务器\图8-4 服务器基本框架.png)

### 服务器基本块

| 模块         | 单个服务器程序             | 服务器机群                   |
| ------------ | -------------------------- | ---------------------------- |
| I/O处理单元  | 处理客户连接，读写网络数据 | 作为接入服务器，实现负载均衡 |
| 逻辑单元     | 业务进程或线程             | 逻辑服务器                   |
| 网络存储单元 | 本地数据库、文件或缓存     | 数据库服务器                 |
| 请求队列     | 各单元之间的通信方式       | 各服务器之间的永久 TCP 连接  |

### I/O处理单元

是服务器管理客户连接的模块。它通常要完成以下工作：等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是，数据的收发不一定在I/O处理单元中执行，也可能 在逻辑单元中执行，具体在何处执行取决于事件处理模式（见后 文）。对于一个服务器机群来说，I/O处理单元是一个专门的接入服务器。它实现负载均衡，从所有逻辑服务器中选取负荷最小的一台来为新客户服务。

### 逻辑单元

通常是一个进程或线程。它分析并处理客户数据， 然后将结果传递给I/O处理单元或者直接发送给客户端（具体使用哪种方式取决于事件处理模式）。对服务器机群而言，一个逻辑单元本身就是一台逻辑服务器。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并行处理

### 网络存储单元

可以是数据库、缓存和文件，甚至是一台独立的服务器。但它不是必须的，比如ssh、telnet等登录服务就不需要这个单元。

### 请求队列

是各单元之间的通信方式的抽象。I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样， 多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。

请求队列通常被实现为池的一部分，我们将在后面讨论池的概念。==对于服务器机群而言，请求队列是各台服务器之间预先 建立的、静态的、永久的TCP连接。==这种TCP连接能提高服务器之间交 换数据的效率，因为它避免了动态建立TCP连接导致的额外的系统开 销。

## I/O模型

### 阻塞和非阻塞

==socket在创建的时候默认是阻塞的。==我们可以给socket 系统调用的第2个参数传递SOCK_NONBLOCK标志，或者通过fcntl系 统调用的F_SETFL命令，将其设置为非阻塞的。阻塞和非阻塞的概念能应用于所有文件描述符，而不仅仅是socket。我们称阻塞的文件描述符为阻塞I/O，称非阻塞的文件描述符为非阻塞I/O。

==针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。==比如，客户端通过connect向服务器 发起连接时，connect将首先发送同步报文段给服务器，然后等待服务 器返回确认报文段。如果服务器的确认报文段没有立即到达客户端， 则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调 用。==socket的基础API中，可能被阻塞的系统调用包括accept、send、 recv和connect。==

==针对非阻塞I/O执行的系统调用则总是立即返回，而不管事件是否已经发生。==如果事件没有立即发生，这些系统调用就返回-1，和出错的 情况一样。此时我们必须根据errno来区分这两种情况。对accept、send 和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一 次”）或者EWOULDBLOCK（意为“期望阻塞”）；对connect而言， errno则被设置成EINPROGRESS（意为“在处理中”）

很显然，我们==只有在事件已经发生的情况下操作非阻塞I/O（读、 写等），才能提高程序的效率。==因此，非阻塞I/O通常要和其他I/O通知 机制一起使用，比如I/O复用和SIGIO信号。

### I/O复用

I/O复用是最常使用的I/O通知机制。它指的是，应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。Linux上常用的I/O复用函数是select、poll和 epoll_wait，我们将在第9章详细讨论它们。

==需要指出的是，I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。==

### SIGIO信号

SIGIO信号也可以用来报告I/O事件。6.8节的最后一段提到，==我们可以为一个目标文件描述符指定宿主进程，那么被指定的宿主进程将 捕获到SIGIO信号。==这样，当目标文件描述符上有事件发生时，SIGIO 信号的信号处理函数将被触发，我们也就可以在该信号处理函数中对 目标文件描述符执行非阻塞I/O操作了。关于信号的使用，我们将在第 10章讨论。

### 异步I/O

从理论上说，阻塞I/O、I/O复用和信号驱动I/O==都是同步I/O模型。== 因为在这三种I/O模型中，I/O的读写操作，都是在I/O事件发生之后， 由应用程序来完成的。

而POSIX规范所定义的异步I/O模型则不同。==对异步I/O而言，用户可以直接对I/O执行读写操作，这些操作告诉内核用 户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。==

异步I/O的读写操作总是立即返回，而不论I/O是否是阻塞的，因为 真正的读写操作已经由内核接管。也就是说，同步I/O模型要求用户代 码自行执行I/O操作（将数据从内核缓冲区读入用户缓冲区，或将数据 从用户缓冲区写入内核缓冲区），而异步I/O机制则由内核来执行I/O操 作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完 成的）。

你可以这样认为，同步I/O向应用程序通知的是I/O就绪事件， 而异步I/O向应用程序通知的是I/O完成事件。Linux环境下，aio.h头文 件中定义的函数提供了对异步I/O的支持。不过这部分内容不是本书的 重点，所以只做简单的讨论。

![表8-2 IO模型对比](C:\Users\Administrator\Desktop\笔记\llinux服务器\表8-2 IO模型对比.png)

## 两种高效的事件处理模式

服务器程序通常需要处理三类事件：I/O事件、信号及定时事件。 我们将在后续章节依次讨论这三种类型的事件，这一节先从整体上介绍一下两种高效的事件处理模式：Reactor和Proactor。

### Reactor模式

Reactor是这样一种模式，它要求主线程（I/O处理单元，下同）==只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程==（逻辑单元，下同）。==除此之外，主线程不做任何其他实质性的工作。==读写数据，接受新的连接，以及处理客户请求均在工作线程 中完成。

使用同步I/O模型（以epoll_wait为例）实现的Reactor模式的工作流程是：

1）主线程往epoll内核事件表中注册socket上的读就绪事件。

2）主线程调用epoll_wait等待socket上有数据可读。 

3）当socket上有数据可读时，epoll_wait通知主线程。主线程则将 ocket可读事件放入请求队列。 

4）睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就 绪事件。 

5）主线程调用epoll_wait等待socket可写。 

6）当socket可写时，epoll_wait通知主线程。主线程将socket可写事 件放入请求队列。 

7）睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入 服务器处理客户请求的结果。

![图8-5 reactor模式](C:\Users\Administrator\Desktop\笔记\llinux服务器\图8-5 reactor模式.png)

工作线程从请求队列中取出事件后，将根据事件的类型 来决定如何处理它：对于可读事件，执行读数据和处理请求的操作； 对于可写事件，执行写数据的操作。因此，图8-5所示的Reactor模式 中，没必要区分所谓的“读工作线程”和“写工作线程”。

### Proactor模式

与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内 核来处理，工作线程仅仅负责业务逻辑。因此，Proactor模式更符合图 8-4所描述的服务器编程框架

使用异步I/O模型（以aio_read和aio_write为例）实现的Proactor模 式的工作流程是：

1）主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序 （这里以信号为例，详情请参考sigevent的man手册）。 

2）主线程继续处理其他逻辑。 

3）当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用

4）应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注 册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操 作完成时如何通知应用程序（仍然以信号为例）。 

5）主线程继续处理其他逻辑。 

6）当用户缓冲区的数据被写入socket之后，内核将向应用程序发 送一个信号，以通知应用程序数据已经发送完毕。 

7）应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。

![图8-6 proactor模式](C:\Users\Administrator\Desktop\笔记\llinux服务器\图8-6 proactor模式.png)

连接socket上的读写事件是通过aio_read/aio_write向内核注册的，因此内核将通过信号来向应用程序报告连接socket上的读写事件。所以，==主线程中的epoll_wait调用仅能用来检测监听socket上的连接请求事件，而不能用来检测连接socket上的读写事件==

## 两种高效的并发模式

并发编程的目的是让程序“同时”执行多个任务。如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换使效率降低。 

但如果程序是I/O密集型的，比如经常读写文件，访问数据库等，则情况就不同了。

由于I/O操作的速度远没有CPU的计算速度快，所以让程序阻塞于I/O操作将浪费大量的CPU时间。如果程序有多个执行线程， 则当前被I/O操作所阻塞的执行线程可主动放弃CPU（或由操作系统来 调度），并将执行权转移到其他线程。这样一来，CPU就可以用来做 更加有意义的事情（除非所有线程都同时被I/O操作所阻塞），而不是 等待I/O操作完成，因此CPU的利用率显著提升。

服务器主要有两种并发编程模式：半同步/半异步（half-sync/halfasync）模式和领导者/追随者（Leader/Followers）模式。我们将依次讨 论之。

### 半同步/半异步（half-sync/halfasync）模式

==半同步/半异步模式中的“同步”和“异步”与前面讨论的I/O模 型中的“同步”和“异步”是完全不同的概念。==

对于像服务器这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程序，我们就应该==同时使用同步线程和异步线程来实现，即采用半同步/ 半异步模式来实现。==

半同步/半异步模式中，==同步线程用于处理客户逻辑，==相当于图8-4 中的逻辑单元；==异步线程用于处理I/O事件，==相当于图8-4中的I/O处理 单元。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并 处理该请求对象。具体选择哪个工作线程来为新的客户请求服务，则取决于请求队列的设计。比如最简单的轮流选取工作线程的Round Robin算法，也可以通过条件变量（见第14章）或信号量（见第14章） 来随机地选择一个工作线程。

![图8-9 半同步和半异步模式的工作流程](C:\Users\Administrator\Desktop\笔记\llinux服务器\图8-9 半同步和半异步模式的工作流程.png)

#### 半同步/半反应堆模式

在服务器程序中，如果结合考虑两种事件处理模式和几种I/O模 型，则半同步/半异步模式就存在多种变体。其中有一种变体称为半同 步/半反应堆（half-sync/half-reactive）模式，

![图8-10 半同步半反应堆模式](C:\Users\Administrator\Desktop\笔记\llinux服务器\图8-10 半同步半反应堆模式.png)

异步线程只有一个，由主线程来充当。它负责监听所有 socket上的事件。如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生， 即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接 socket插入请求队列中。==所有工作线程都睡眠在请求队列上，当有任务 到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权。==这 种竞争机制使得只有空闲的工作线程才有机会来处理新任务，这是很 合理的。

缺点：主线程和工作线程共享请求队列。主线程往请求队列中添加任 务，或者工作线程从请求队列中取出任务，都需要对请求队列==加锁保护，从而白白耗费CPU时间。==每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这一问题， 则工作线程的切换也将耗费大量CPU时间。

#### 高效的半同步/半异步模式

![图8-11 高效的半同步半异步模式](C:\Users\Administrator\Desktop\笔记\llinux服务器\图8-11 高效的半同步半异步模式.png)

主线程只管理监听socket，连接socket由工作线程来管理。==当有新的连接到来时，主线程就接受之并将新返回的连接socket派 发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工 作线程来处理，直到客户关闭连接。==主线程向工作线程派发socket的最 简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测 到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。 如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表 中。

每个线程（主线程和工作线程）都维持自己的事件循环，它们各自独立地监听不同的事件。因此，在这种高效的半同步/半异步模式中，每个线程都工作在异步模式，所以它并非严格意义 上的半同步/半异步模式。

### 领导者/追随者模式

领导者/追随者模式是多个工作线程==轮流==获得事件源集合，轮流监听、分发并处理事件的一种模式。

在任意时间点，程序都==仅有一个领导者线程，==它负责监听I/O事件。而其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者。当前的领导者如果检测到I/O事件， 首先要从线程池中推选出新的领导者线程，然后处理I/O事件

此时，==新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件，二者实现了并发。==

领导者/追随者模式包含如下几个组件：句柄集（HandleSet）、线 程集（ThreadSet）、事件处理器（EventHandler）和具体的事件处理器 （ConcreteEventHandler）。

![图8-12 领导者追随者模式的组件](C:\Users\Administrator\Desktop\笔记\llinux服务器\图8-12 领导者追随者模式的组件.png)

#### 句柄集

 ==句柄（Handle）用于表示I/O资源，==在Linux下通常就是一个文件描述符。句柄集管理众多句柄，它使用wait_for_event方法来监听这些句 柄上的I/O事件，并将其中的就绪事件通知给领导者线程。领导者则调用绑定到Handle上的事件处理器来处理事件。领导者将Handle和事件处理器绑定是通过调用句柄集中的register_handle方法实现的。

#### 线程集

这个组件是==所有工作线程（包括领导者线程和追随者线程）的管理者。==它负责各线程之间的同步，以及新领导者线程的推选。线程集 中的线程在任一时间必处于如下三种状态之一：

❑Leader：线程当前处于领导者身份，负责等待句柄集上的I/O事件。 

❑Processing：线程正在处理事件。领导者检测到I/O事件之后，可以转移到Processing状态来处理该事件，并调用promote_new_leader方法推选新的领导者；==也可以指定其他追随者来处理事件（Event Handoff），此时领导者的地位不变。==当处于Processing状态的线程处理完事件之后，如果当前线程集中没有领导者，则它将成为新的领导者，否则它就直接转变为追随者。 

❑Follower：线程当前处于追随者身份，通过调用线程集的join方法等待成为新的领导者，也可能被当前的领导者指定来处理新的任务。

<img src="C:\Users\Administrator\Desktop\笔记\llinux服务器\图8-13 领导者追随者模式的状态转移.png" alt="图8-13 领导者追随者模式的状态转移" style="zoom:67%;" />

#### 事件处理器和具体的事件处理器

事件处理器通常包含一个或多个回调函数handle_event。==这些回调函数用于处理事件对应的业务逻辑。==事件处理器在使用前需要被绑定 到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器中的回调函数。具体的事件处理器是事件处理器的派生 类。它们必须重新实现基类的handle_event方法，以处理特定的任务。 

![图8-14 领导者追随者模式](C:\Users\Administrator\Desktop\笔记\llinux服务器\图8-14 领导者追随者模式.png)

#### 优缺点

由于领导者线程自己监听I/O事件并处理客户请求，因而领导者/追 随者模式不需要在线程之间传递任何额外的数据，也无须像半同步/半 反应堆模式那样在线程之间同步对请求队列的访问。

但领导者/追随者的一个明显缺点是仅支持一个事件源集合，因此也无法像图8-11所示的那样，让每个工作线程独立地管理多个客户连接。

## 有限状态机

前面两节探讨的是服务器的I/O处理单元、请求队列和逻辑单元之间协调完成任务的各种模式，这一节我们介绍==逻辑单元内部==的一种高 效编程方法：有限状态机（finite state machine）。

==有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，==服务器可以根据它来编写相应的处理逻 辑

```C++
STATE_MACHINE()
{
    State cur_State=type_A;
    while(cur_State!=type_C)
    {
        Package_pack=getNewPackage();
        switch(cur_State)
        {
            case type_A:
            process_package_state_A(_pack);
            cur_State=type_B;
            break;
            case type_B:
            process_package_state_B(_pack);
            cur_State=type_C;
            break;
        }
    }
}
//这是一个带状态转移的有限状态机
//该状态机包含三种状态：type_A、type_B和type_C。
//其中type_A是状态机的开始状态，type_C是状态机的结束状态。
//状态机的当前状态记录在cur_State变量中。
//在一趟循环过程中，状态机先通过getNewPackage方法获得一个新的数据包，然后根据cur_State变量的值判断如何处理该数据包。数据包处理完之后，状态机通过给cur_State变量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环时，它将执行新的状态对应的逻辑
```

### 有限状态机的实例：HTTP请求的读取和分析

很多网络协议，包括TCP协议和IP协议，都在其头部中提供头部长度字段。程序根据该字段的值就可以知道是否接收到一个完整的协议头部。

==但HTTP协议并未提供这样的头部长度字段，并且其头部长度变化也很大，可以只有十几字节，也可以有上百字节。==

根据协议规定， 我们判断HTTP头部结束的依据是遇到一个空行，该空行仅包含一对回 车换行符（＜CR＞＜LF＞）。如果一次读操作没有读入HTTP请求的整个头部，即没有遇到空行，那么我们必须等待客户继续写数据并再次读入。因此，我们每完成一次读操作，就要分析新读入的数据中是否有空行。不过在寻找空行的过程中，我们可以同时完成对整个HTTP请求头部的分析（记住，空行前面还有请求行和头部域），以提高解析HTTP请求的效率。

代码清单8-3使用主、从两个有限状态机实现了最简单的HTTP请求的读取和分析。为了使表述简洁，我们约定，==直接称 HTTP请求的一行（包括请求行和头部字段）为行。==

```C++
#include＜sys/socket.h＞
#include＜netinet/in.h＞
#include＜arpa/inet.h＞
#include＜assert.h＞
#include＜stdio.h＞
#include＜stdlib.h＞
#include＜unistd.h＞
#include＜errno.h＞
#include＜string.h＞
#include＜fcntl.h＞
#define BUFFER_SIZE 4096/*读缓冲区大小*/
/*主状态机的两种可能状态，分别表示：当前正在分析请求行，当前正在分析头部字段*/
enum CHECK_STATE{CHECK_STATE_REQUESTLINE=0,CHECK_STATE_HEADER};
/*从状态机的三种可能状态，即行的读取状态，分别表示：读取到一个完整的行、行出错和行数据尚且不完整*/
enum LINE_STATUS{LINE_OK=0,LINE_BAD,LINE_OPEN};
/*服务器处理HTTP请求的结果：NO_REQUEST表示请求不完整，需要继续读取客户数
据；GET_REQUEST表示获得了一个完整的客户请求；BAD_REQUEST表示客户请求有语法错
误；FORBIDDEN_REQUEST表示客户对资源没有足够的访问权限；INTERNAL_ERROR表示服
务器内部错误；CLOSED_CONNECTION表示客户端已经关闭连接了*/
enum HTTP_CODE{NO_REQUEST,GET_REQUEST,BAD_REQUEST,FORBIDDEN_REQUEST,INTERNAL_ERROR,CLOSED_CONNECTION};
/*为了简化问题，我们没有给客户端发送一个完整的HTTP应答报文，而只是根据服务器的处理结果发送如下成功或失败信息*/
static const char*szret[]={"I get a correct result\n","Something wrong\n"};
/*从状态机，用于解析出一行内容*/
LINE_STATUS parse_line(char*buffer,int＆checked_index,int＆read_index)
{
    char temp;
    /*checked_index指向buffer（应用程序的读缓冲区）中当前正在分析的字节，
    read_index指向buffer中客户数据的尾部的下一字节。buffer中第0～checked_index
    字节都已分析完毕，第checked_index～(read_index-1)字节由下面的循环挨个分析*/
    for(;checked_index＜read_index;++checked_index)
    {
        /*获得当前要分析的字节*/
        temp=buffer[checked_index];
        /*如果当前的字节是“\r”，即回车符，则说明可能读取到一个完整的行*/
        if(temp=='\r')
        {
            /*如果“\r”字符碰巧是目前buffer中的最后一个已经被读入的客户数据，那么这次分
            析没有读取到一个完整的行，返回LINE_OPEN以表示还需要继续读取客户数据才能进一步分
            析*/
            if((checked_index+1)==read_index)
            {
                return LINE_OPEN;
            }
            /*如果下一个字符是“\n”，则说明我们成功读取到一个完整的行*/
            else if(buffer[checked_index+1]=='\n')
            {
                buffer[checked_index++]='\0';
                buffer[checked_index++]='\0';
                return LINE_OK;
            }
            /*否则的话，说明客户发送的HTTP请求存在语法问题*/
            return LINE_BAD;
        }
        /*如果当前的字节是“\n”，即换行符，则也说明可能读取到一个完整的行*/
        else if(temp=='\n')
        {
            if((checked_index＞1)＆＆buffer[checked_index-1]=='\r')
            {
                buffer[checked_index-1]='\0';
                buffer[checked_index++]='\0';
                return LINE_OK;
            }
            return LINE_BAD;
        }
    }
    /*如果所有内容都分析完毕也没遇到“\r”字符，则返回LINE_OPEN，表示还需要继续读取客户数据才能进一步分析*/
    return LINE_OPEN;
}
/*分析请求行*/
HTTP_CODE parse_requestline(char*temp,CHECK_STATE＆checkstate)
{
    char*url=strpbrk(temp,"\t");
    /*如果请求行中没有空白字符或“\t”字符，则HTTP请求必有问题*/
    if(!url)
    {
        return BAD_REQUEST;
    }
    *url++='\0';
    char*method=temp;
    if(strcasecmp(method,"GET")==0)/*仅支持GET方法*/
    {
        printf("The request method is GET\n");
    }
    else
    {
        return BAD_REQUEST;
    }
    url+=strspn(url,"\t");
    char*version=strpbrk(url,"\t");
    if(!version)
    {
        return BAD_REQUEST;
    }
    *version++='\0';
    version+=strspn(version,"\t");
    /*仅支持HTTP/1.1*/
    if(strcasecmp(version,"HTTP/1.1")!=0)
    {
        return BAD_REQUEST;
    }
    /*检查URL是否合法*/
    if(strncasecmp(url,"http://",7)==0)
    {
        url+=7;
        url=strchr(url,'/');
    }
    if(!url||url[0]!='/')
    {
        return BAD_REQUEST;
    }
    printf("The request URL is:%s\n",url);
    /*HTTP请求行处理完毕，状态转移到头部字段的分析*/
    checkstate=CHECK_STATE_HEADER;
    return NO_REQUEST;
}
/*分析头部字段*/
HTTP_CODE parse_headers(char*temp)
{
    /*遇到一个空行，说明我们得到了一个正确的HTTP请求*/
    if(temp[0]=='\0')
    {
        return GET_REQUEST;
    }
    else if(strncasecmp(temp,"Host:",5)==0)/*处理“HOST”头部字段*/
    {
        temp+=5;
        temp+=strspn(temp,"\t");
        printf("the request host is:%s\n",temp);
    }
    else/*其他头部字段都不处理*/
    {
        printf("I can not handle this header\n");
    }
    return NO_REQUEST;
}
/*分析HTTP请求的入口函数*/
HTTP_CODE parse_content(char*buffer,int＆checked_index,CHECK_STATE＆checkstate,int＆read_index,int＆start_line)
{
    LINE_STATUS linestatus=LINE_OK;/*记录当前行的读取状态*/
    HTTP_CODE retcode=NO_REQUEST;/*记录HTTP请求的处理结果*/
    /*主状态机，用于从buffer中取出所有完整的行*/
    while((linestatus=parse_line(buffer,checked_index,read_index))==LINE_OK)
    {
        char*temp=buffer+start_line;/*start_line是行在buffer中的起始位置*/
        start_line=checked_index;/*记录下一行的起始位置*/
        /*checkstate记录主状态机当前的状态*/
        switch(checkstate)
        {
            case CHECK_STATE_REQUESTLINE:/*第一个状态，分析请求行*/
                {
                    retcode=parse_requestline(temp,checkstate);
                    if(retcode==BAD_REQUEST)
                    {
                        return BAD_REQUEST;
                    }
                    break;
                }
            case CHECK_STATE_HEADER:/*第二个状态，分析头部字段*/
                {
                    retcode=parse_headers(temp);
                    if(retcode==BAD_REQUEST)
                    {
                        return BAD_REQUEST;
                    }
                    else if(retcode==GET_REQUEST)
                    {
                        return GET_REQUEST;
                    }
                    break;
                }
            default:
                {
                    return INTERNAL_ERROR;
                }
        }
    }
    /*若没有读取到一个完整的行，则表示还需要继续读取客户数据才能进一步分析*/
    if(linestatus==LINE_OPEN)
    {
        return NO_REQUEST;
    }
    else
    {
        return BAD_REQUEST;
    }
}
int main(int argc,char*argv[])
{
    if(argc＜=2)
    {
        printf("usage:%s ip_address port_number\n",basename(argv[0]));
        return 1;
    }
    const char*ip=argv[1];
    int port=atoi(argv[2]);
    struct sockaddr_in address;
    bzero(＆address,sizeof(address));
    address.sin_family=AF_INET;
    inet_pton(AF_INET,ip,＆address.sin_addr);
    address.sin_port=htons(port);
    int listenfd=socket(PF_INET,SOCK_STREAM,0);
    assert(listenfd＞=0);
    int ret=bind(listenfd,(struct sockaddr*)＆address,sizeof(address));
    assert(ret!=-1);
    ret=listen(listenfd,5);
    assert(ret!=-1);
    struct sockaddr_in client_address;
    socklen_t client_addrlength=sizeof(client_address);
    int fd=accept(listenfd,(struct sockaddr*)＆client_address,＆client_addrlength);
    if(fd＜0)
    {
        printf("errno is:%d\n",errno);
    }
    else
    {
        char buffer[BUFFER_SIZE];/*读缓冲区*/
        memset(buffer,'\0',BUFFER_SIZE);
        int data_read=0;
        int read_index=0;/*当前已经读取了多少字节的客户数据*/
        int checked_index=0;/*当前已经分析完了多少字节的客户数据*/
        int start_line=0;/*行在buffer中的起始位置*/
        /*设置主状态机的初始状态*/
        CHECK_STATE checkstate=CHECK_STATE_REQUESTLINE;
        while(1)/*循环读取客户数据并分析之*/
        {
            data_read=recv(fd,buffer+read_index,BUFFER_SIZE-read_index,0);
            if(data_read==-1)
            {
                printf("reading failed\n");
                break;
            }
            else if(data_read==0)
            {
                printf("remote client has closed the connection\n");
                break;
            }
            read_index+=data_read;
            /*分析目前已经获得的所有客户数据*/
            HTTP_CODE
                result=parse_content(buffer,checked_index,checkstate,read_index,start_line);
            if(result==NO_REQUEST)/*尚未得到一个完整的HTTP请求*/
            {
                continue;
            }
            else if(result==GET_REQUEST)/*得到一个完整的、正确的HTTP请求*/
            {
                send(fd,szret[0],strlen(szret[0]),0);
                break;
            }
            else/*其他情况表示发生错误*/
            {
                send(fd,szret[1],strlen(szret[1]),0);
                break;
            }
        }
        close(fd);
    }
    close(listenfd);
    return 0;
}
```

两个有限状态机分别称为主状态机和从状 态机，这体现了它们之间的关系：主状态机在内部调用从状态机。下 面先分析从状态机，即parse_line函数，它从buffer中解析出一个行。图 8-15描述了其可能的状态及状态转移过程。

<img src="C:\Users\Administrator\Desktop\笔记\llinux服务器\图8-15 从状态机的状态转移图.png" alt="图8-15 从状态机的状态转移图" style="zoom:67%;" />

这个状态机的初始状态是LINE_OK，==其原始驱动力来自于buffer中新到达的客户数据。==在main函数中，我们循环调用recv函数往buffer中 读入客户数据。每次成功读取数据后，我们就调用parse_content函数来 分析新读入的数据。parse_content函数首先要做的就是调用parse_line函 数来获取一个行。现在假设服务器经过一次recv调用之后，buffer的内容以及部分变量的值如图8-16a所示。

![图8-16 parse_line函数的工作过程](C:\Users\Administrator\Desktop\笔记\llinux服务器\图8-16 parse_line函数的工作过程.png)

a）调用recv后，buffer里的初始内容和部分变量的值 b）parse_line函 数处理buffer后的结果 c）再次调用recv后的结果 d）parse_line函数 再次处理buffer后的结果

主状态机使用checkstate变量来记录当前的状态。如果当前的状态是CHECK_STATE_REQUESTLINE，则表示parse_line函数解析出的行 是请求行，于是主状态机调用parse_requestline来分析请求行；如果当 前的状态是CHECK_STATE_HEADER，则表示parse_line函数解析出的 是头部字段，于是主状态机调用parse_headers来分析头部字段。 checkstate变量的初始值是CHECK_STATE_REQUESTLINE， parse_requestline函数在成功地分析完请求行之后将其设置为 CHECK_STATE_HEADER，从而实现状态转移。

## 提高服务器性能的其他建议

性能对服务器来说是至关重要的，毕竟每个客户都期望其请求能 很快地得到响应。影响服务器性能的首要因素就是系统的硬件资源， 比如CPU的个数、速度，内存的大小等。不过由于硬件技术的飞速发 展，现代服务器都不缺乏硬件资源。因此，我们需要考虑的主要问题 是如何从“软环境”来提升服务器的性能。==服务器的“软环境”，一方面 是指系统的软件资源，比如操作系统允许用户打开的最大文件描述符 数量；另一方面指的就是服务器程序本身，即如何从编程的角度来确 保服务器的性能，==这是本节要讨论的问题。

### 池

既然服务器的硬件资源“充裕”，那么提高服务器性能的一个很直 接的方法就是以空间换时间，即“浪费”服务器的硬件资源，以换取其 运行效率。这就是池（pool）的概念。

池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。当服务器进入正式运行阶段，即开始处理客户请求的时候，==如果它需要相关的资源，就可以直接从池中获取，无须动态分配。==很显然，直接从池中取得所需资源比动态分配资源的速度要快得多，因为分配系统资源的系统调用都是很耗时的。当服务器处理完一个客户连接后，可以把相关的资源放回池中，无须执行系统调用来释放资源。 ==从最终的效果来看，池相当于服务器管理系统资源的应用层设施，它避免了服务器对内核的频繁访问。==

不过，既然池中的资源是预先静态分配的，我们就无法预期应该 分配多少资源。这个问题又该如何解决呢？==最简单的解决方案就是分 配“足够多”的资源，即针对每个可能的客户连接都分配必要的资源。==这通常会导致资源的浪费，因为任一时刻的客户数量都可能远远没有 达到服务器能支持的最大客户数量。好在这种资源的浪费对服务器来 说一般不会构成问题。还有一种解决方案是预先分配一定的资源，此 后如果发现资源不够用，就再动态分配一些并加入池中。

#### 内存池

内存池通常用于socket的接收缓存和发送缓存。对于某些长度有限的客户请求，比如HTTP请求，预先分配一个大小足够（比如5000字 节）的接收缓存区是很合理的。当客户请求的长度超过接收缓冲区的 大小时，我们可以选择丢弃请求或者动态扩大接收缓冲区。

#### 进程池和线程池

是并发编程常用的“伎俩”。当我们需要一个工 作进程或工作线程来处理新到来的客户请求时，我们可以直接从进程 池或线程池中取得一个执行实体，而无须动态地调用fork或 pthread_create等函数来创建进程和线程

#### 连接池

通常用于服务器或服务器机群的内部永久连接。图8-4中， 每个逻辑单元可能都需要频繁地访问本地的某个数据库。简单的做法是：逻辑单元每次需要访问数据库的时候，就向数据库程序发起连接，而访问完毕后释放连接。很显然，这种做法的效率太低。一种解 决方案是使用连接池。连接池是服务器预先和数据库程序建立的一组 连接的集合。当某个逻辑单元需要访问数据库时，它可以直接从连接 池中取得一个连接的实体并使用之。待完成数据库的访问之后，逻辑 单元再将该连接返还给连接池。

### 数据复制

高性能服务器应该==避免不必要的数据复制，==尤其是当数据复制发生在用户代码和内核之间的时候。

比如ftp服务器，当客户 请求一个文件时，服务器只需要检测目标文件是否存在，以及客户是 否有读取它的权限，而绝对不会关心文件的具体内容。这样的话，ftp 服务器就无须把目标文件的内容完整地读入到应用程序缓冲区中并调 用send函数来发送，而是可以使用“零拷贝”函数sendfile来直接将其发 送给客户端。

此外，==用户代码内部（不访问内核）的数据复制也是应该避免的。==举例来说，当两个工作进程之间要传递大量的数据时，我们就应该考虑使用共享内存来在它们之间直接共享这些数据，而不是使用管道或者消息队列来传递。又比如代码清单8-3所示的解析HTTP请求的实例中，我们用指针（start_line）来指出每个行在buffer中的起始位 置，以便随后对行内容进行访问，而不是把行的内容复制到另外一个缓冲区中来使用，因为这样既浪费空间，又效率低下。

### 上下文切换和锁

并发程序必须考虑上下文切换（context switch）的问题，即==进程切换或线程切换导致的的系统开销。==

。即使是I/O密集型的服务器，也不 应该使用过多的工作线程（或工作进程，下同），==否则线程间的切换将占用大量的CPU时间，服务器真正用于处理业务逻辑的CPU时间的 比重就显得不足了。==

因此，为每个客户连接都创建一个工作线程的服 务器模型是不可取的。图8-11所描述的半同步/半异步模式是一种比较合理的解决方案，它允许一个线程同时处理多个客户连接。此外，多线程服务器的一个优点是不同的线程可以同时运行在不同的CPU上。 当线程的数量不大于CPU的数目时，上下文的切换就不是问题了。

并发程序需要考虑的另外一个问题是共享资源的加锁保护。==锁通常被认为是导致服务器效率低下的一个因素，因为由它引入的代码不仅不处理任何业务逻辑，而且需要访问内核资源。==因此，服务器如果有更好的解决方案，就应该避免使用锁。显然，图8-11所描述的半同 步/半异步模式就比图8-10所描述的半同步/半反应堆模式的效率高。==如果服务器必须使用“锁”，则可以考虑减小锁的粒度，比如使用读写 锁。==当所有工作线程都只读取一块共享内存的内容时，读写锁并不会增加系统的额外开销。只有当其中某一个工作线程需要写这块内存 时，系统才必须去锁住这块区域。

# 第九章 I/O复用
