## extern关键字的作用

[1]: https://blog.csdn.net/u014436243/article/details/90635791

这篇博文讲的很好了，对于变量而言，如果你想在一个cpp中引用另一个cpp的==全局变量==，必须在头文件里用extern声明或者在前者的cpp中用extern声明，对于函数而言，由于声明和定义是一样的，所以不需要显式使用extern。

## 全局变量和静态变量的初始化值

| 数据类型 | 初始化默认值 |
| -------- | ------------ |
| int      | 0            |
| char     | '\0'         |
| float    | 0            |
| double   | 0            |

注意局部变量如果不初始化，会导致不可预测的错误！

## 宽字符常量

关键字为wchar_t，如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 **wchar_t** 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 **char** 类型的简单变量中。

## 字符串常量的分行

可以使用 \ 做分隔符，把一个很长的字符串常量进行分行。

```C
    string greeting2 = "hello, \
                       runoob";
```

## unsigned隐含了int的含义

```c
unsigned x;
unsigned int y;
```

这两行都声明了int类型的变量

## volatile关键字

[2]: https://blog.csdn.net/qq_40843865/article/details/90729496

主要是存入变量的位置，volatile会将变量存入内存而非寄存器中，会降低一定的效率，但是可以保证变量操作的顺序。

## static关键词

**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

在 C++ 中，当 static 用在类数据成员上时，会导致==仅有一个==该成员的副本被类的所有对象共享。

==static被内部函数修改时，会被永远修改==

## thread_local关键字

使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。

## 左右移位的补数规则

左移<<：二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。

右移>>：二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。

## 一些不常用但是存在的赋值运算符

| %=   | 求模且赋值运算符，求两个操作数的模赋值给左边操作数 | C %= A 相当于 C = C % A   |
| ---- | -------------------------------------------------- | ------------------------- |
| <<=  | 左移且赋值运算符                                   | C <<= 2 等同于 C = C << 2 |
| >>=  | 右移且赋值运算符                                   | C >>= 2 等同于 C = C >> 2 |
| &=   | 按位与且赋值运算符                                 | C &= 2 等同于 C = C & 2   |
| ^=   | 按位异或且赋值运算符                               | C ^= 2 等同于 C = C ^ 2   |
| \|=  | 按位或且赋值运算符                                 | C \|= 2 等同于 C = C \| 2 |

## lambda函数

其实就是一种简单创建函数的方法

```c
[capture](parameters)->return-type{body}
auto f = [](int a) -> int {return a + 1;};
cout << f(3) << endl;  //输出4
```

但是第二个parameters是可以省略的，但是要在前面的capture说明好最后的变量是如何获取，否则会报错

```c
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。

auto x1 = []{return i_;};  // error,没有捕获外部变量
auto x2 = [=]{return i_ + x + y;}; //ok，按值捕获所有外部变量
auto x3 = [&]{return i_ + x + y;}; //ok，按引用捕获所有外部变量
auto x4 = [this]{return i_;}; //ok，捕获this指针
auto x5 = [this]{return i_ + x + y;}; //error,没有捕获x和y变量
auto x6 = [this,x,y]{return i_ + x + y;}; //ok，捕获了this指针和x、y变量
auto x7 = [this]{return i_++;}; //ok，捕获了this指针，修改成员变量的值
```

## cmath文件

如果要想使用一系列数学函数例如sin和cos，就必须#include <cmath>

## 数组作为函数参数

声明时，数组的长度是无关紧要的

```c
void myFunction(int param[])
```

可以直接不声明长度

## 字符串（数组）char [ ] 操作

| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |
| ---- | ------------------------------------------------------------ |
| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 **+** 号，例如: `string str1 = "runoob"; string str2 = "google"; string str = str1 + str2;` |
| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |
| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。 |
| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |
| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |

要先#include <cstring>

## NULL指针

被赋予NULL的指针就是空指针，在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

```c
if(ptr)     /* 如果 ptr 非空，则完成 */
if(!ptr)    /* 如果 ptr 为空，则完成 */
```

可以用来避免使用了空指针

## 引用与指针

引用和指针不同，

- 不存在空引用。引用必须连接到一块合法的内存。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。

```c
int i = 17;
int&  r = i;
```

## ctime时间文件

要使用时间类型时，看这个链接

[3]: https://www.runoob.com/cplusplus/cpp-date-time.html

## cin的连续使用

```c
cin >> name >> age;
```

## cerr错误流和clog日志流

cerr与cout很像，使用的方式也一样，但用于显示错误消息。默认情况下被关联到标准输出流，但它不被缓冲，也就说错误消息可以直接发送到显示器，而无需等到缓冲区或者新的换行符时，才被显示。一般情况下不被重定向。

```c++
#include <iostream>
int` `main() {
std::cout << ``"hello world---cout"` `<< std::endl ;
std::cerr << ``"hello world---cerr"` `<< std::endl ;
return` `0;
}
```

clog和cout也一样，但是**clog** 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。

只有在写大型项目时这些区别才明显。

## 类的拷贝构造函数

**拷贝构造函数**是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象。
- ==复制对象把它作为参数传递给函数。==
- 复制对象，并从==函数返回这个对象。==

```c++
classname (const classname &obj) {
   // 构造函数的主体
}

Line::Line(const Line &obj)
{
    cout << "调用拷贝构造函数并为指针 ptr 分配内存" << endl;
    ptr = new int;
    *ptr = *obj.ptr; // 拷贝值
}
```

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。==如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。==

## C++内联函数

C++ **内联函数**是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。

对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 **inline**，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

在类定义中的定义的函数都是内联函数，即使没有使用 **inline** 说明符。

引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：

- 1.在内联函数内不允许使用循环语句和开关语句；
- 2.内联函数的定义必须出现在内联函数第一次调用之前；
- 3.类结构中所在的类说明内部定义的函数是内联函数。

Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.

定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.

优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.

缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。

结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!

## this指针

在 C++ 中，每一个对象都能通过 **this** 指针来访问自己的地址。**this** 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。

==友元函数没有 **this** 指针==，因为友元不是类的成员。只有成员函数才有 **this** 指针。

## 类的静态成员

对于static静态成员数据，其在所有同类中共享，也就是说只要修改了在所有类中的值都会被修改。

而对于static静态成员函数，可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，**静态函数**只要使用类名加范围解析运算符 **::** 就可以访问。

静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。

静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。

- 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。
- 普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。

## 派生类的权限

派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。

我们可以根据访问权限总结出不同的访问类型，如下所示：

| 访问     | public | protected | private |
| :------- | :----- | :-------- | :------ |
| 同一个类 | yes    | yes       | yes     |
| 派生类   | yes    | yes       | no      |
| 外部的类 | yes    | no        | no      |

一个派生类继承了所有的基类方法，但下列情况除外：

- 基类的构造函数、析构函数和拷贝构造函数。
- ==基类的重载运算符。==
- ==基类的友元函数。==

## 多继承

一个子类可以有多个父类，它继承了多个父类的特性。

```C++
class Rectangle: public Shape, public PaintCost
{
   public:
      int getArea()
      { 
         return (width * height); 
      }
};
```

## 重载函数

==不能==仅通过返回类型的不同来重载函数。

## 虚函数与纯虚函数

在父类和子类中定义了同名函数时，为了能正确调用不同类中的函数，也就是动态链接而非静态链接，需要在父类的同名函数中加入virtual关键字。

## 文件的输入输出流

[4]: https://www.runoob.com/cplusplus/cpp-files-streams.html

## new无法使用的情况

如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：

```c++
double* pvalue  = NULL;
if( !(pvalue  = new double ))
{
   cout << "Error: out of memory." <<endl;
   exit(1);
 
}
```

**malloc()** 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。

## 数组与二维数组的new创建语法

```c++
har* pvalue  = NULL;   // 初始化为 null 的指针
pvalue  = new char[20]; // 为变量请求内存
```

下面是二维数组

```c++
int **array
// 假定数组第一维长度为 m， 第二维长度为 n
// 动态分配空间
array = new int *[m];
for( int i=0; i<m; i++ )
{
    array[i] = new int [n]  ;
}
//释放
for( int i=0; i<m; i++ )
{
    delete [] array[i];
}
delete [] array;
```

## 不连续的命名空间

下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：

```c++
namespace namespace_name {
   // 代码声明
}
```

## 嵌套的命名空间

```c++
namespace namespace_name1 {
   // 代码声明
   namespace namespace_name2 {
      // 代码声明
   }
}
// 访问 namespace_name2 中的成员
using namespace namespace_name1::namespace_name2;
 
// 访问 namespace_name1 中的成员
using namespace namespace_name1;
```

在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素==也是可用的==。

## 预处理语句

预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。

所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。

## 一些有用的预定义宏

| 宏       | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| __LINE__ | 这会在程序编译时包含当前行号。                               |
| __FILE__ | 这会在程序编译时包含当前文件名。                             |
| __DATE__ | 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 |
| __TIME__ | 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 |

```c++
cout << "Value of __LINE__ : " << __LINE__ << endl;
cout << "Value of __FILE__ : " << __FILE__ << endl;
cout << "Value of __DATE__ : " << __DATE__ << endl;
cout << "Value of __TIME__ : " << __TIME__ << endl;
```

输出结果如下：

```
Value of __LINE__ : 6
Value of __FILE__ : test.cpp
Value of __DATE__ : Feb 28 2011
Value of __TIME__ : 18:52:48
```

