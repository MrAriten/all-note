# 第一章

## 在使用getchar等输入输出函数时，定义的变量是int

```c
int main ()
{
    int c;
    while((c = getchar())!=EOF)
        putchar(c);
}
```

之所以要这样，是因为必须把c说明成一个大到足以存放getchar函数可能返回的各种值的类型。

## 输出的格式

%d	打印十进制整数

%6d	打印十进制整数，至少六个字符宽

%f	打印浮点数

%6.2f	打印浮点数，至少六个字符宽，且里面包含两个小数点

%.0f	打印浮点数但是只打印整数部分

## 符号常量

#define PPE 1

其实就是定义一个符号常量

## 变量初始化！！！

在使用一个记数程序时，一定要先把计数的变量初始化为0！！

## 关于EOF

在win系统下的EOF应该是通过Crtl+D输入的，但是不知道为什么Clion输入不了

## 关于putchar

putchar是只有在输入了回车以后才会一个一个对getchar的字符进行读取！并不是说直接读取一整串字符！

## getline函数的理解

getline是获取输入字符中的某一行并读取到一个字符串数组当中。

因为getchar是在不断的读取输入流的，所以当读取完第一行的时候，getline再次调用，是读取到第二行的而==不会重新读取第一行！==

练习1.19的reverse函数就只是利用了getline读取的一行然后进行的翻转。

## 在不利用size类函数的情况下判断字符串长度

判断每行的长度，如果只有一行，那么就要同时判断/n和/0，/0是空字符，是所有输入流的终点。

如果有多行，就用/n判断每行长度，/n是输入流的结尾！

%s在printf中，是通过有无/0来判断这是否为字符串变量的。

## 外部变量

前面有提到过用define定义的符号常量，要弄清其与外部变量的区别

外部变量是在所有函数之外定义的变量，可以被函数调用，但1、是并不会被修改值，在退出函数后，外部变量将恢复至原来的值。

显式调用外部变量要用extern关键字，但是如果外部变量是在最前面定义的，extern可以不写

但是如果全局变量定义在外部文件或者文档末端，extern就必须显示调用

# 第二章

## 变量名

对于变量名，_下划线也是看做字母的，就是可以 _abc 作为一个变量名

## 常量

对于long常量 特别是在Define中定义的 要加上后缀 例如1234L。无符号常量要带上U，12U代表int的unsigned量。12UL则是long的unsigned。

八进制和十六进制，则是前缀，八进制是前面带个0 如31可以写成八进制数037。而十六进制的前缀是0x

‘\0’一般用作字符串的最后一位，==其值就是0==

枚举常量enmu，默认从0开始，但是你也可以自己设定其中的值，但是后一个的值如果不设置，就是比前一个值大1。

==外部变量和静态变量如果没初始化，则值为0，自动变量是未知值==

==const==用于限定该值不能被改变，如果硬要改变，会导致奇怪的后果。

## 关系运算符

== != < >= >

一般最好用 !valid来判断是否为0比用 valid == 0看起来舒服

## 类型转换

==用float的计算速度会比双精度的double快一点==

当包括unsigned的时候，long和int的类型大小就比较麻烦了。

比如 -1L<1U，这是因为int类型的-1U被提升为signed long类型了

强制转换就是在数的前面加类型

## ++与--

++和--在前面则先加/减后运算，反之先运算。

注意这个运算符==不能用在表达式上==，只能用在变量，例如(i+j)++是非法的！

双指针法经常用到++和--，因为检测的指针永远比操作的指针跑得快

对于

```c
s[i] = 1;
i++;
可以转换为
s[i++] = 1;
或者在一些转换数组的程序中可以直接
s[i++]=k[j++]
```

## 位运算符

位运算符==只能用于整数==！

左移与右移运算符是自动补0

## 条件表达式

if和else的使用最好用缩进表示

(a>b)?a:b 这种问号条件表达式一定要会运用！在很多地方都可以直接用！==简单直接的把条件和结果都写入了==

但是要注意，如果a是int，b是float的话，最后的结果就算输出是a，都会是float类型！

# 第三章

## if-else语句

注意else永远是和最近的一个if匹配，为了防止误判，最好是用缩进以及花括号！

## switch语句

对于相同的case情况，例如判断是否为数字，0~9都为数字时：

```
case'0':case'1':case'2'
```

可以直接==连写case==

对于退出switch可以直接加上break

## while循环和for循环

while循环和for的区别，for是可以在循环前后做一次操作，要注意，for和while的条件判断语句是很灵活多样的，不要只局限于判断长度，可以将之前习惯的==for循环内的判断直接加入到for的第二个条件式中！==

同时，for循环的表达式1和表达式3是可以写入多个操作的，==用逗号即可==

```c
for (i =0,j=0; i < j; i++,j--)
```

但是这种操作最好就是i和j要有密切关联，否则容易出错。

## break和continue

break可以直接跳出循环，而continue是执行下一次循环

# 第四章

## 返回值最好是-1

因为C语言中的数组下标多以0开始，这样是最好防止错误的。

## 函数是可以全部缺省的

直接连返回类型都不写那种

dummy(){}

这种函数的作用只是占位而已

## 外部变量

如果存在函数需要共享某些数据而函数之间却不相互调用，外部变量是最好的。

但是外部变量使用太多了的话，可能会导致外部变量数据交错太多。

如果外部变量在==外部源文件==中，要显式的使用 extern 关键字，否则会被当做自己文件的外部变量。

## 静态变量

静态关键字static能直接==让外部文件不能访问该外部变量==，只会让自己的源文件访问这些变量

static同样能加在函数定义前面，这样函数就不能被外部文件所访问。

static加了以后，这个变量从程序开始就会一直存在直到程序结束。

## 寄存器变量

#这个不常用，就是前面声明个register，让变量在寄存器中运算，会更快一点。

## 初始化

没有初始化时，==外部变量和静态变量会被初始化为0==，但是自动变量是不定值。

数组的初始化，可以通过直接声明，但是如果声明的量小于数组的尺寸时，==会用0补齐==，无论是不是自动变量

两个定义数组的等价方法：

```c
char p[] = "abc"
char p[] = {'a','b','c'}
```

## C预处理程序

#include如果后面接的是双引号，那就是工程中的文件被引用

如果是尖括号，那就按实现的定义来查找文件

## 宏替换

#define 名字 替换文本

这个可以用来定义一些简单的函数，例如

```C
#define max(A,B) ((A)>(B)?(A):(B))
```

但是要注意的是，这种方式有风险，如果不带括号的话，比如

```c
#define square(x) x*x
```

因为define的==核心是替换==，如果用上面那个，当你使用squrae(x+1)时，程序会输出 x+1*x+1，那就不是x的平方了，而是2x+1

可以用#undef来取消对宏名字的定义

# 第五章

## 指针的基本操作

指针不能对表达式、常量和寄存器变量操作。

指向void类型的指针可以转换成任何对象类型的指针，但是不能间接引用自身。

++*ip是可以的，但是 *ip++是不行的，会被判断成 *(ip++)，其实要的效果是( *ip)++

## 指针的运算操作是比数组下标运算要快的

对于指针

```c
int a[];
int * pa;
pa = a;
pa = &a[0];
3、4行的代码效果是一样的，a可以是一个指针地址，但是要注意
```

==a不是变量，不能被修改==

```c
char a[];
char *a;
```

这两个代码在效果上是一样的，在传递函数参数时，我们也更喜欢后者

## 地址算术运算

p++在数组中是指向前一个，当p指向了数组中间时，p[-1]也是合法的。

## 指针与整数不能互换，但0可以

指针为0代表着NULL，是空指针，一般也是用NULL来代表0

## 指针间的对比

如果p和q是指向同一个数组，那么p和q就可以用><=等符号来判断大小，当他们不是同一个数组用这个方法会出现问题

任何指针和0的相等或不等的比较都有意义。

如果p和q指向相同数组的元素且p<q，那么q-p+1代表着这两个元素之间的距离

## 数组创建和指针创建的区别

之前说过

```C
char a[];
char *a;
//在函数参数中是一样的，但是在声明数组时
char a[] = 'abc';
char *a ='abc';
//却又是不一样的，下面那个a只是把自己的地址赋予到了后面那串字符串中，但是如果试图修改下面那个a的字符串，结果将不确定
```

## 对于判断字符串到达结尾的判断条件

```c
while ((*s = *t) != '\0'){
    s++;
    t++;}
//这个条件看似最简单，但是还可以再化简
while((*s++ = *t++))
//首先是直接把++移动到了判断中，其次，while本就是判断0，后面那个是多余的，字符串最后一位本就是0    
```

## 用指针数组的栈操作

```c
*p++ = val; //将val压进栈
val = *--p; //将栈顶元素弹出到val中
```

## 二维数组作为变元给传递函数

```c
function ( int table[][10]);
function(int (*table)[10]);
//只需要声明列数，不需要声明行数
//但是不能写成 *table[10]，这声明了一个有10个元素的指针数组
```

==指针数组≠二维数组==

指针数组存储的是地址，二维数组存储的是元素

## 函数指针

```c
int * f() ;//返回一个指向整数类型对象指针的函数
int (*f)();//返回一个指向函数的指针，该函数返回一个整数
```

# 第六章

